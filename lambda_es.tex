\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Introduction}



 In this work, we present a formalization of the substitution lemma\cite{barendregtLambdaCalculusIts1984} in a general framework that extends the $\lambda$-calculus with an explicit substitution operator. The formalization is done in the Coq proof assistant\cite{teamCoqProofAssistant2021} and the source code is available at: \vspace{0.25cm}


 \url{https://github.com/flaviodemoura/lx_confl/tree/m_subst_lemma} \vspace{0.25cm}


The substitution lemma is an important result concerning the composition of the substitution operation, and is usually presented as follows in the context of the $\lambda$-calculus:


\begin{tcolorbox}
 Let $t,u$ and $v$ be $\lambda$-terms. If $x\notin FV(v)$ ({\it i.e.} $x$ does not occur in the set of free variables of the term $v$) then $\metasub{\metasub{t}{x}{u}}{y}{v} =_\alpha \metasub{\metasub{t}{y}{v}}{x}{\metasub{u}{y}{v}}$.
\end{tcolorbox}


This is a well known result already formalized in the context of the $\lambda$-calculus \cite{berghoferHeadtoHeadComparisonBruijn2007}. Nevertheless, in the context of $\lambda$-calculi with explicit substitutions its formalization is not straightforward due to the interaction between the metasubstitution and the explicit substitution operator. Our formalization is done in a nominal setting that uses the MetaLib\footnote{\url{https://github.com/plclub/metalib}} package of Coq, but no particular explicit substitution calculi is taken into account because the expected behaviour between the metasubstitution operation with the explicit substitutition constructor is the same regardless the calculus. The contributions of this work are twofold:


\begin{enumerate}
\item The formalization is modular in the sense that no particular calculi with explicit substitutions is taken into account. Therefore, we believe that this formalization could be seen as a generic framework for proving properties of these calculi that uses the substitution lemma in the nominal setting\cite{kesnerPerpetualityFullSafe2008,nakazawaCompositionalConfluenceProofs2016,nakazawaPropertyShufflingCalculus2023};
\item A solution to a circularity problem in the proofs is given. It adds an axiom to the formalization that replaces the set equality by the syntactic equality. In this way, we are allowed to replace/rewrite sets of (free) variables by another sets of (free) variables in arbitrary contexts.
\end{enumerate}


This document is built directly from a Coq script using the CoqDoc\footnote{\url{https://coq.inria.fr/refman/using/tools/coqdoc.html}} tool. In the following section, we present the general framework and the basics of the nominal approach. In Section 3, we present our definition of metasubstitution and some of its properties. In Section 4, we present the main theorem, {\it i.e.} the substitution lemma, and we conclude in Section 5.

\section{A syntactic extension of the $\lambda$-calculus}



 In this section, we present the framework of the formalization, which is based on a nominal approach\cite{gabbayNewApproachAbstract1999} where variables use names. In the nominal setting, variables are represented by atoms that are structureless entities with a decidable equality: 


\begin{verbatim}
Parameter eq_dec : forall x y : atom, {x = y} + {x <> y}.
\end{verbatim}


\noindent therefore different names mean different atoms and different variables. The nominal approach is close to the usual paper and pencil notation used in $\lambda$-calculus lectures, whose grammar of terms is given by:


\begin{equation}\label{lambda:grammar}
 t ::= x \mid \lambda_x.t \mid t\ t
\end{equation}


\noindent and its main rule, named $\beta$-reduction, is given by:


\begin{equation}\label{lambda:beta}
 (\lambda_x.t)\ u \to_{\beta} \metasub{t}{x}{u}
\end{equation}
\noindent where $\metasub{t}{x}{u}$ represents the term obtained from $t$ after replacing all its free occurrences of the variable $x$ by $u$ in a way that renaming of bound variable is done in order to avoid variable capture. In other words, $\metasub{t}{x}{u}$ is a metanotation for a capture free substitution. For instance, the $\lambda$-term $(\lambda_x\lambda_y.x\ y)\ y$ has both bound and free occurrences of the variable $y$. In order to $\beta$-reduce it one has to replace (or substitute) the free variable $y$ for all free occurrences of the variable $x$ in the term $(\lambda_y.x\ y)$. But a straight substitution will capture the free variable $y$, {\it i.e.} this means that the free occurrence of $y$ before the $\beta$-reduction will become bound after the $\beta$-reduction step. A renaming of bound variables is done to avoid such capture, so in this example, one can take an $\alpha$-equivalent\footnote{A formal definition of this notion will be given later in this section.} term, say $(\lambda_z.x\ z)$, and perform the $\beta$-step correctly as $(\lambda_x\lambda_y.x\ y)\ y \to_{\beta} \lambda_z.y\ z$. The renaming of variables in the nominal setting is done via a name-swapping, which is formally defined as follows:


$\vswap{x}{y}{z} := \left\{ \begin{array}{ll}
y, & \mbox{ if } z = x; \\
x, & \mbox{ if } z = y; \\
z, & \mbox{ otherwise. } \\
\end{array}\right.$


This notion can be extended to $\lambda$-terms in a straightfoward way:


$\swap{x}{y}{t} := \left\{ \begin{array}{ll}
\vswap{x}{y}{z}, & \mbox{ if } t = z; \\
\lambda_{\vswap{x}{y}{z}}.\swap{x}{y}{t_1}, & \mbox{ if } t = \lambda_z.t_1; \\
\swap{x}{y}{t_1}\ \swap{x}{y}{t_2}, & \mbox{ if } t = t_1\ t_2\\
\end{array}\right.$


In the previous example, one could apply a swap to avoid the variable capture in the following way: $(\lambda_x\lambda_y.x\ y)\ y \to_{\beta} \metasub{\swap{x}{z}{(\lambda_y.x\ y)}}{x}{y} = \lambda_z.y\ z$. Could we have used a variable substitution instead of a swapping in the previous example? Sure! We could have done the reduction as $(\lambda_x\lambda_y.x\ y)\ y \to_{\beta} \metasub{\metasub{(\lambda_y.x\ y)}}{x}{y}{x}{z} = \lambda_z.y\ z$, but as we will see soon, variable substitution is not stable under $\alpha$-equivalence, and this stability property is necessary to work modulo $\alpha$-equivalence.


In what follows, we will interleave metanotation with the corresponding Coq notation because this strategy will be better for explaining the proof steps of the forthcoming lemmas. So the swapping of variables, named \coqdocvar{swap\_var}, is defined as follows: 
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Definition} \coqdef{lambda es.swap var}{swap\_var}{\coqdocdefinition{swap\_var}} (\coqdef{lambda es.x:27}{x}{\coqdocbinder{x}}:\coqdocabbreviation{atom}) (\coqdef{lambda es.y:28}{y}{\coqdocbinder{y}}:\coqdocabbreviation{atom}) (\coqdef{lambda es.z:29}{z}{\coqdocbinder{z}}:\coqdocabbreviation{atom}) := \coqdockw{if} (\coqref{lambda es.z:29}{\coqdocvariable{z}} \coqdocnotation{==} \coqref{lambda es.x:27}{\coqdocvariable{x}}) \coqdockw{then} \coqref{lambda es.y:28}{\coqdocvariable{y}} \coqdockw{else} \coqdockw{if} (\coqref{lambda es.z:29}{\coqdocvariable{z}} \coqdocnotation{==} \coqref{lambda es.y:28}{\coqdocvariable{y}}) \coqdockw{then} \coqref{lambda es.x:27}{\coqdocvariable{x}} \coqdockw{else} \coqref{lambda es.z:29}{\coqdocvariable{z}}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
The next step is to extend the variable renaming operation to terms, which in our case corresponds to $\lambda$-terms augmented with an explicit substitution operation. We use \coqdocvar{n\_sexp} to denote the set of nominal expressions equipped with an explicit substitution operator, which, for simplicity, we will refer to as just ``terms'', and the corresponding grammar is outlined below: 
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{lambda es.n sexp}{n\_sexp}{\coqdocinductive{n\_sexp}} : \coqdockw{Set} :=\coqdoceol
\coqdocindent{0.50em}
\ensuremath{|} \coqdef{lambda es.n var}{n\_var}{\coqdocconstructor{n\_var}} (\coqdef{lambda es.x:34}{x}{\coqdocbinder{x}}:\coqdocabbreviation{atom})\coqdoceol
\coqdocindent{0.50em}
\ensuremath{|} \coqdef{lambda es.n abs}{n\_abs}{\coqdocconstructor{n\_abs}} (\coqdef{lambda es.x:35}{x}{\coqdocbinder{x}}:\coqdocabbreviation{atom}) (\coqdef{lambda es.t:36}{t}{\coqdocbinder{t}}:\coqref{lambda es.n sexp:32}{\coqdocinductive{n\_sexp}})\coqdoceol
\coqdocindent{0.50em}
\ensuremath{|} \coqdef{lambda es.n app}{n\_app}{\coqdocconstructor{n\_app}} (\coqdef{lambda es.t1:37}{t1}{\coqdocbinder{t1}}:\coqref{lambda es.n sexp:32}{\coqdocinductive{n\_sexp}}) (\coqdef{lambda es.t2:38}{t2}{\coqdocbinder{t2}}:\coqref{lambda es.n sexp:32}{\coqdocinductive{n\_sexp}})\coqdoceol
\coqdocindent{0.50em}
\ensuremath{|} \coqdef{lambda es.n sub}{n\_sub}{\coqdocconstructor{n\_sub}} (\coqdef{lambda es.t1:39}{t1}{\coqdocbinder{t1}}:\coqref{lambda es.n sexp:32}{\coqdocinductive{n\_sexp}}) (\coqdef{lambda es.x:40}{x}{\coqdocbinder{x}}:\coqdocabbreviation{atom}) (\coqdef{lambda es.t2:41}{t2}{\coqdocbinder{t2}}:\coqref{lambda es.n sexp:32}{\coqdocinductive{n\_sexp}}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\noindent where \coqdocvar{n\_var} is the constructor for variables, \coqdocvar{n\_abs} for abstractions, \coqdocvar{n\_app} for applications and \coqdocvar{n\_sub} for the explicit substitution. Explicit substitution calculi are formalisms that deconstruct the metasubstitution operation into more granular steps, thereby functioning as an intermediary between the $\lambda$-calculus and its practical implementations. In other words, these calculi shed light on the execution models of higher-order languages\cite{kesnerTheoryExplicitSubstitutions2009}. The \coqdocvar{size} of terms and the set \coqdocvar{fv\_nom} of the free variables of a term are defined as usual: 
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{lambda es.size}{size}{\coqdocdefinition{size}} (\coqdef{lambda es.t:42}{t}{\coqdocbinder{t}} : \coqref{lambda es.n sexp}{\coqdocinductive{n\_sexp}}) : \coqexternalref{nat}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Datatypes}{\coqdocinductive{nat}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqref{lambda es.t:42}{\coqdocvariable{t}} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{lambda es.n var}{\coqdocconstructor{n\_var}} \coqdocvar{x} \ensuremath{\Rightarrow} 1\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{lambda es.n abs}{\coqdocconstructor{n\_abs}} \coqdocvar{x} \coqdocvar{t} \ensuremath{\Rightarrow} 1 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqref{lambda es.size:43}{\coqdocdefinition{size}} \coqref{lambda es.t:42}{\coqdocvariable{t}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{lambda es.n app}{\coqdocconstructor{n\_app}} \coqdocvar{t1} \coqdocvar{t2} \ensuremath{\Rightarrow} 1 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqref{lambda es.size:43}{\coqdocdefinition{size}} \coqdocvar{t1} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqref{lambda es.size:43}{\coqdocdefinition{size}} \coqdocvar{t2}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{lambda es.n sub}{\coqdocconstructor{n\_sub}} \coqdocvar{t1} \coqdocvar{x} \coqdocvar{t2} \ensuremath{\Rightarrow} 1 \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqref{lambda es.size:43}{\coqdocdefinition{size}} \coqdocvar{t1} \coqexternalref{::nat scope:x '+' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Peano}{\coqdocnotation{+}} \coqref{lambda es.size:43}{\coqdocdefinition{size}} \coqdocvar{t2}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{lambda es.fv nom}{fv\_nom}{\coqdocdefinition{fv\_nom}} (\coqdef{lambda es.t:45}{t}{\coqdocbinder{t}} : \coqref{lambda es.n sexp}{\coqdocinductive{n\_sexp}}) : \coqdocabbreviation{atoms} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqref{lambda es.t:45}{\coqdocvariable{t}} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{lambda es.n var}{\coqdocconstructor{n\_var}} \coqdocvar{x} \ensuremath{\Rightarrow} \coqdocnotation{\{\{}\coqdocvar{x}\coqdocnotation{\}\}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{lambda es.n abs}{\coqdocconstructor{n\_abs}} \coqdocvar{x} \coqdocvar{t1} \ensuremath{\Rightarrow} \coqdocabbreviation{remove} \coqdocvar{x} (\coqref{lambda es.fv nom:46}{\coqdocdefinition{fv\_nom}} \coqdocvar{t1})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{lambda es.n app}{\coqdocconstructor{n\_app}} \coqdocvar{t1} \coqdocvar{t2} \ensuremath{\Rightarrow} \coqref{lambda es.fv nom:46}{\coqdocdefinition{fv\_nom}} \coqdocvar{t1} \coqdocnotation{`}\coqdocnotation{union}\coqdocnotation{`} \coqref{lambda es.fv nom:46}{\coqdocdefinition{fv\_nom}} \coqdocvar{t2}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{lambda es.n sub}{\coqdocconstructor{n\_sub}} \coqdocvar{t1} \coqdocvar{x} \coqdocvar{t2} \ensuremath{\Rightarrow} \coqdocnotation{(}\coqdocabbreviation{remove} \coqdocvar{x} (\coqref{lambda es.fv nom:46}{\coqdocdefinition{fv\_nom}} \coqdocvar{t1})\coqdocnotation{)} \coqdocnotation{`}\coqdocnotation{union}\coqdocnotation{`} \coqref{lambda es.fv nom:46}{\coqdocdefinition{fv\_nom}} \coqdocvar{t2}\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The action of a permutation on a term, written $\swap{x}{y}{t}$, is inductively defined as follows:\vspace{.5cm}


$\swap{x}{y}{t} := \left\{ \begin{array}{ll}
\vswap{x}{y}{v}, & \mbox{ if } t \mbox{ is the variable } v; \\
\lambda_{\vswap{x}{y}{z}}. \swap{x}{y}{t_1}, & \mbox{ if } t = \lambda_z.t_1; \\
\swap{x}{y}{t_1}\ \swap{x}{y}{t_2}, & \mbox{ if } t = t_1\ t_2;\\
\esub{\swap{x}{y}{t_1}}{\vswap{x}{y}{z}}{\swap{x}{y}{t_2}}, & \mbox{ if } t = \esub{t_1}{z}{t_2}.
\end{array}\right.$ \vspace{.5cm}


The corresponding Coq definition is given by the following recursive function: 
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Fixpoint} \coqdef{lambda es.swap}{swap}{\coqdocdefinition{swap}} (\coqdef{lambda es.x:48}{x}{\coqdocbinder{x}}:\coqdocabbreviation{atom}) (\coqdef{lambda es.y:49}{y}{\coqdocbinder{y}}:\coqdocabbreviation{atom}) (\coqdef{lambda es.t:50}{t}{\coqdocbinder{t}}:\coqref{lambda es.n sexp}{\coqdocinductive{n\_sexp}}) : \coqref{lambda es.n sexp}{\coqdocinductive{n\_sexp}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqref{lambda es.t:50}{\coqdocvariable{t}} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{lambda es.n var}{\coqdocconstructor{n\_var}} \coqdocvar{z}     \ensuremath{\Rightarrow} \coqref{lambda es.n var}{\coqdocconstructor{n\_var}} (\coqref{lambda es.swap var}{\coqdocdefinition{swap\_var}} \coqref{lambda es.x:48}{\coqdocvariable{x}} \coqref{lambda es.y:49}{\coqdocvariable{y}} \coqdocvar{z})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{lambda es.n abs}{\coqdocconstructor{n\_abs}} \coqdocvar{z} \coqdocvar{t1}  \ensuremath{\Rightarrow} \coqref{lambda es.n abs}{\coqdocconstructor{n\_abs}} (\coqref{lambda es.swap var}{\coqdocdefinition{swap\_var}} \coqref{lambda es.x:48}{\coqdocvariable{x}} \coqref{lambda es.y:49}{\coqdocvariable{y}} \coqdocvar{z}) (\coqref{lambda es.swap:51}{\coqdocdefinition{swap}} \coqref{lambda es.x:48}{\coqdocvariable{x}} \coqref{lambda es.y:49}{\coqdocvariable{y}} \coqdocvar{t1})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{lambda es.n app}{\coqdocconstructor{n\_app}} \coqdocvar{t1} \coqdocvar{t2} \ensuremath{\Rightarrow} \coqref{lambda es.n app}{\coqdocconstructor{n\_app}} (\coqref{lambda es.swap:51}{\coqdocdefinition{swap}} \coqref{lambda es.x:48}{\coqdocvariable{x}} \coqref{lambda es.y:49}{\coqdocvariable{y}} \coqdocvar{t1}) (\coqref{lambda es.swap:51}{\coqdocdefinition{swap}} \coqref{lambda es.x:48}{\coqdocvariable{x}} \coqref{lambda es.y:49}{\coqdocvariable{y}} \coqdocvar{t2})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{lambda es.n sub}{\coqdocconstructor{n\_sub}} \coqdocvar{t1} \coqdocvar{z} \coqdocvar{t2} \ensuremath{\Rightarrow} \coqref{lambda es.n sub}{\coqdocconstructor{n\_sub}} (\coqref{lambda es.swap:51}{\coqdocdefinition{swap}} \coqref{lambda es.x:48}{\coqdocvariable{x}} \coqref{lambda es.y:49}{\coqdocvariable{y}} \coqdocvar{t1}) (\coqref{lambda es.swap var}{\coqdocdefinition{swap\_var}} \coqref{lambda es.x:48}{\coqdocvariable{x}} \coqref{lambda es.y:49}{\coqdocvariable{y}} \coqdocvar{z}) (\coqref{lambda es.swap:51}{\coqdocdefinition{swap}} \coqref{lambda es.x:48}{\coqdocvariable{x}} \coqref{lambda es.y:49}{\coqdocvariable{y}} \coqdocvar{t2})\coqdoceol
\coqdocindent{1.00em}
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
The \coqdocvar{swap} function preserves the size of terms, as stated by the following lemma: 
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdef{lambda es.swap size eq}{swap\_size\_eq}{\coqdoclemma{swap\_size\_eq}} : \coqdockw{\ensuremath{\forall}} \coqdef{lambda es.x:63}{x}{\coqdocbinder{x}} \coqdef{lambda es.y:64}{y}{\coqdocbinder{y}} \coqdef{lambda es.t:65}{t}{\coqdocbinder{t}}, \coqref{lambda es.size}{\coqdocdefinition{size}} (\coqref{lambda es.swap}{\coqdocdefinition{swap}} \coqref{lambda es.x:63}{\coqdocvariable{x}} \coqref{lambda es.y:64}{\coqdocvariable{y}} \coqref{lambda es.t:65}{\coqdocvariable{t}}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{lambda es.size}{\coqdocdefinition{size}} \coqref{lambda es.t:65}{\coqdocvariable{t}}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
Equivariance is an important property of swap:
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdef{lambda es.swap var equivariance}{swap\_var\_equivariance}{\coqdoclemma{swap\_var\_equivariance}} : \coqdockw{\ensuremath{\forall}} \coqdef{lambda es.v:85}{v}{\coqdocbinder{v}} \coqdef{lambda es.x:86}{x}{\coqdocbinder{x}} \coqdef{lambda es.y:87}{y}{\coqdocbinder{y}} \coqdef{lambda es.z:88}{z}{\coqdocbinder{z}} \coqdef{lambda es.w:89}{w}{\coqdocbinder{w}},\coqdoceol
\coqdocindent{2.00em}
\coqref{lambda es.swap var}{\coqdocdefinition{swap\_var}} \coqref{lambda es.x:86}{\coqdocvariable{x}} \coqref{lambda es.y:87}{\coqdocvariable{y}} (\coqref{lambda es.swap var}{\coqdocdefinition{swap\_var}} \coqref{lambda es.z:88}{\coqdocvariable{z}} \coqref{lambda es.w:89}{\coqdocvariable{w}} \coqref{lambda es.v:85}{\coqdocvariable{v}}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{=}}\coqdoceol
\coqdocindent{2.00em}
\coqref{lambda es.swap var}{\coqdocdefinition{swap\_var}} (\coqref{lambda es.swap var}{\coqdocdefinition{swap\_var}} \coqref{lambda es.x:86}{\coqdocvariable{x}} \coqref{lambda es.y:87}{\coqdocvariable{y}} \coqref{lambda es.z:88}{\coqdocvariable{z}}) (\coqref{lambda es.swap var}{\coqdocdefinition{swap\_var}} \coqref{lambda es.x:86}{\coqdocvariable{x}} \coqref{lambda es.y:87}{\coqdocvariable{y}} \coqref{lambda es.w:89}{\coqdocvariable{w}}) (\coqref{lambda es.swap var}{\coqdocdefinition{swap\_var}} \coqref{lambda es.x:86}{\coqdocvariable{x}} \coqref{lambda es.y:87}{\coqdocvariable{y}} \coqref{lambda es.v:85}{\coqdocvariable{v}}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{lambda es.swap equivariance}{swap\_equivariance}{\coqdoclemma{swap\_equivariance}} : \coqdockw{\ensuremath{\forall}} \coqdef{lambda es.t:90}{t}{\coqdocbinder{t}} \coqdef{lambda es.x:91}{x}{\coqdocbinder{x}} \coqdef{lambda es.y:92}{y}{\coqdocbinder{y}} \coqdef{lambda es.z:93}{z}{\coqdocbinder{z}} \coqdef{lambda es.w:94}{w}{\coqdocbinder{w}},\coqdoceol
\coqdocindent{2.00em}
\coqref{lambda es.swap}{\coqdocdefinition{swap}} \coqref{lambda es.x:91}{\coqdocvariable{x}} \coqref{lambda es.y:92}{\coqdocvariable{y}} (\coqref{lambda es.swap}{\coqdocdefinition{swap}} \coqref{lambda es.z:93}{\coqdocvariable{z}} \coqref{lambda es.w:94}{\coqdocvariable{w}} \coqref{lambda es.t:90}{\coqdocvariable{t}}) \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{lambda es.swap}{\coqdocdefinition{swap}} (\coqref{lambda es.swap var}{\coqdocdefinition{swap\_var}} \coqref{lambda es.x:91}{\coqdocvariable{x}} \coqref{lambda es.y:92}{\coqdocvariable{y}} \coqref{lambda es.z:93}{\coqdocvariable{z}}) (\coqref{lambda es.swap var}{\coqdocdefinition{swap\_var}} \coqref{lambda es.x:91}{\coqdocvariable{x}} \coqref{lambda es.y:92}{\coqdocvariable{y}} \coqref{lambda es.w:94}{\coqdocvariable{w}}) (\coqref{lambda es.swap}{\coqdocdefinition{swap}} \coqref{lambda es.x:91}{\coqdocvariable{x}} \coqref{lambda es.y:92}{\coqdocvariable{y}} \coqref{lambda es.t:90}{\coqdocvariable{t}}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The notion of $\alpha$-equivalence is defined in the usual way by the following rules:


\begin{mathpar}
 \inferrule*[Right={({\rm\it aeq\_var})}]{~}{x =_\alpha x} \and  \inferrule*[Right={({\rm\it aeq\_abs\_same})}]{t_1 =_\alpha t_2}{\lambda_x.t_1 =_\alpha \lambda_x.t_2} 
\end{mathpar}


\begin{mathpar}
\inferrule*[Right={({\rm\it aeq\_abs\_diff})}]{x \neq y \and x \notin fv(t_2) \and t_1 =_\alpha \swap{y}{x}{t_2}}{\lambda_x.t_1 =_\alpha \lambda_y.t_2} 
\end{mathpar}


\begin{mathpar}
 \inferrule*[Right={({\rm\it aeq\_app})}]{t_1 =_\alpha t_1' \and t_2 =_\alpha t_2'}{t_1\ t_2 =_\alpha t_1'\ t_2'} \and  \inferrule*[Right={({\rm\it aeq\_sub\_same})}]{t_1 =_\alpha t_1' \and t_2 =_\alpha t_2'}{\esub{t_1}{x}{t_2} =_\alpha \esub{t_1'}{x}{t_2'}} 
\end{mathpar}


\begin{mathpar}
\inferrule*[Right={({\rm\it aeq\_sub\_diff})}]{t_2 =_\alpha t_2' \and x \neq y \and x \notin fv(t_1') \and t_1 =_\alpha \swap{y}{x}{t_1'}}{\esub{t_1}{x}{t_2} =_\alpha \esub{t_1'}{y}{t_2'}} 
\end{mathpar}


Each of these rules correspond to a constructor in the \coqdocvar{aeq} inductive definition below: 
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Inductive} \coqdef{lambda es.aeq}{aeq}{\coqdocinductive{aeq}} : \coqref{lambda es.n sexp}{\coqdocinductive{n\_sexp}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.n sexp}{\coqdocinductive{n\_sexp}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop} :=\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdef{lambda es.aeq var}{aeq\_var}{\coqdocconstructor{aeq\_var}} : \coqdockw{\ensuremath{\forall}} \coqdef{lambda es.x:121}{x}{\coqdocbinder{x}}, \coqref{lambda es.aeq:119}{\coqdocinductive{aeq}} (\coqref{lambda es.n var}{\coqdocconstructor{n\_var}} \coqref{lambda es.x:121}{\coqdocvariable{x}}) (\coqref{lambda es.n var}{\coqdocconstructor{n\_var}} \coqref{lambda es.x:121}{\coqdocvariable{x}})\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdef{lambda es.aeq abs same}{aeq\_abs\_same}{\coqdocconstructor{aeq\_abs\_same}} : \coqdockw{\ensuremath{\forall}} \coqdef{lambda es.x:122}{x}{\coqdocbinder{x}} \coqdef{lambda es.t1:123}{t1}{\coqdocbinder{t1}} \coqdef{lambda es.t2:124}{t2}{\coqdocbinder{t2}}, \coqref{lambda es.aeq:119}{\coqdocinductive{aeq}} \coqref{lambda es.t1:123}{\coqdocvariable{t1}} \coqref{lambda es.t2:124}{\coqdocvariable{t2}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.aeq:119}{\coqdocinductive{aeq}} (\coqref{lambda es.n abs}{\coqdocconstructor{n\_abs}} \coqref{lambda es.x:122}{\coqdocvariable{x}} \coqref{lambda es.t1:123}{\coqdocvariable{t1}})(\coqref{lambda es.n abs}{\coqdocconstructor{n\_abs}} \coqref{lambda es.x:122}{\coqdocvariable{x}} \coqref{lambda es.t2:124}{\coqdocvariable{t2}})\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdef{lambda es.aeq abs diff}{aeq\_abs\_diff}{\coqdocconstructor{aeq\_abs\_diff}} : \coqdockw{\ensuremath{\forall}} \coqdef{lambda es.x:125}{x}{\coqdocbinder{x}} \coqdef{lambda es.y:126}{y}{\coqdocbinder{y}} \coqdef{lambda es.t1:127}{t1}{\coqdocbinder{t1}} \coqdef{lambda es.t2:128}{t2}{\coqdocbinder{t2}}, \coqref{lambda es.x:125}{\coqdocvariable{x}} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqref{lambda es.y:126}{\coqdocvariable{y}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.x:125}{\coqdocvariable{x}} \coqdocnotation{`}\coqdocnotation{notin}\coqdocnotation{`} \coqref{lambda es.fv nom}{\coqdocdefinition{fv\_nom}} \coqref{lambda es.t2:128}{\coqdocvariable{t2}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.aeq:119}{\coqdocinductive{aeq}} \coqref{lambda es.t1:127}{\coqdocvariable{t1}} (\coqref{lambda es.swap}{\coqdocdefinition{swap}} \coqref{lambda es.y:126}{\coqdocvariable{y}} \coqref{lambda es.x:125}{\coqdocvariable{x}} \coqref{lambda es.t2:128}{\coqdocvariable{t2}}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.aeq:119}{\coqdocinductive{aeq}} (\coqref{lambda es.n abs}{\coqdocconstructor{n\_abs}} \coqref{lambda es.x:125}{\coqdocvariable{x}} \coqref{lambda es.t1:127}{\coqdocvariable{t1}}) (\coqref{lambda es.n abs}{\coqdocconstructor{n\_abs}} \coqref{lambda es.y:126}{\coqdocvariable{y}} \coqref{lambda es.t2:128}{\coqdocvariable{t2}})\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdef{lambda es.aeq app}{aeq\_app}{\coqdocconstructor{aeq\_app}} : \coqdockw{\ensuremath{\forall}} \coqdef{lambda es.t1:129}{t1}{\coqdocbinder{t1}} \coqdef{lambda es.t2:130}{t2}{\coqdocbinder{t2}} \coqdef{lambda es.t1':131}{t1'}{\coqdocbinder{t1'}} \coqdef{lambda es.t2':132}{t2'}{\coqdocbinder{t2'}}, \coqref{lambda es.aeq:119}{\coqdocinductive{aeq}} \coqref{lambda es.t1:129}{\coqdocvariable{t1}} \coqref{lambda es.t1':131}{\coqdocvariable{t1'}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.aeq:119}{\coqdocinductive{aeq}} \coqref{lambda es.t2:130}{\coqdocvariable{t2}} \coqref{lambda es.t2':132}{\coqdocvariable{t2'}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.aeq:119}{\coqdocinductive{aeq}} (\coqref{lambda es.n app}{\coqdocconstructor{n\_app}} \coqref{lambda es.t1:129}{\coqdocvariable{t1}} \coqref{lambda es.t2:130}{\coqdocvariable{t2}}) (\coqref{lambda es.n app}{\coqdocconstructor{n\_app}} \coqref{lambda es.t1':131}{\coqdocvariable{t1'}} \coqref{lambda es.t2':132}{\coqdocvariable{t2'}})\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdef{lambda es.aeq sub same}{aeq\_sub\_same}{\coqdocconstructor{aeq\_sub\_same}} : \coqdockw{\ensuremath{\forall}} \coqdef{lambda es.t1:133}{t1}{\coqdocbinder{t1}} \coqdef{lambda es.t2:134}{t2}{\coqdocbinder{t2}} \coqdef{lambda es.t1':135}{t1'}{\coqdocbinder{t1'}} \coqdef{lambda es.t2':136}{t2'}{\coqdocbinder{t2'}} \coqdef{lambda es.x:137}{x}{\coqdocbinder{x}}, \coqref{lambda es.aeq:119}{\coqdocinductive{aeq}} \coqref{lambda es.t1:133}{\coqdocvariable{t1}} \coqref{lambda es.t1':135}{\coqdocvariable{t1'}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.aeq:119}{\coqdocinductive{aeq}} \coqref{lambda es.t2:134}{\coqdocvariable{t2}} \coqref{lambda es.t2':136}{\coqdocvariable{t2'}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.aeq:119}{\coqdocinductive{aeq}} (\coqref{lambda es.n sub}{\coqdocconstructor{n\_sub}} \coqref{lambda es.t1:133}{\coqdocvariable{t1}} \coqref{lambda es.x:137}{\coqdocvariable{x}} \coqref{lambda es.t2:134}{\coqdocvariable{t2}}) (\coqref{lambda es.n sub}{\coqdocconstructor{n\_sub}} \coqref{lambda es.t1':135}{\coqdocvariable{t1'}} \coqref{lambda es.x:137}{\coqdocvariable{x}} \coqref{lambda es.t2':136}{\coqdocvariable{t2'}})\coqdoceol
\coqdocnoindent
\ensuremath{|} \coqdef{lambda es.aeq sub diff}{aeq\_sub\_diff}{\coqdocconstructor{aeq\_sub\_diff}} : \coqdockw{\ensuremath{\forall}} \coqdef{lambda es.t1:138}{t1}{\coqdocbinder{t1}} \coqdef{lambda es.t2:139}{t2}{\coqdocbinder{t2}} \coqdef{lambda es.t1':140}{t1'}{\coqdocbinder{t1'}} \coqdef{lambda es.t2':141}{t2'}{\coqdocbinder{t2'}} \coqdef{lambda es.x:142}{x}{\coqdocbinder{x}} \coqdef{lambda es.y:143}{y}{\coqdocbinder{y}}, \coqref{lambda es.aeq:119}{\coqdocinductive{aeq}} \coqref{lambda es.t2:139}{\coqdocvariable{t2}} \coqref{lambda es.t2':141}{\coqdocvariable{t2'}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.x:142}{\coqdocvariable{x}} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqref{lambda es.y:143}{\coqdocvariable{y}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.x:142}{\coqdocvariable{x}} \coqdocnotation{`}\coqdocnotation{notin}\coqdocnotation{`} \coqref{lambda es.fv nom}{\coqdocdefinition{fv\_nom}} \coqref{lambda es.t1':140}{\coqdocvariable{t1'}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.aeq:119}{\coqdocinductive{aeq}} \coqref{lambda es.t1:138}{\coqdocvariable{t1}} (\coqref{lambda es.swap}{\coqdocdefinition{swap}} \coqref{lambda es.y:143}{\coqdocvariable{y}} \coqref{lambda es.x:142}{\coqdocvariable{x}} \coqref{lambda es.t1':140}{\coqdocvariable{t1'}}) \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.aeq:119}{\coqdocinductive{aeq}} (\coqref{lambda es.n sub}{\coqdocconstructor{n\_sub}} \coqref{lambda es.t1:138}{\coqdocvariable{t1}} \coqref{lambda es.x:142}{\coqdocvariable{x}} \coqref{lambda es.t2:139}{\coqdocvariable{t2}}) (\coqref{lambda es.n sub}{\coqdocconstructor{n\_sub}} \coqref{lambda es.t1':140}{\coqdocvariable{t1'}} \coqref{lambda es.y:143}{\coqdocvariable{y}} \coqref{lambda es.t2':141}{\coqdocvariable{t2'}}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
In what follows, we use a infix notation for $\alpha$-equivalence in the Coq code: we write \coqdocvar{t} =\coqdocvar{a} \coqdocvar{u} instead of \coqdocvar{aeq} \coqdocvar{t} \coqdocvar{u}. 
\begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
The above notion defines an equivalence relation over the set \coqdocvar{n\_sexp} of nominal expressions with explicit substitutions, {\it i.e.} the \coqdocvar{aeq} relation is reflexive, symmetric and transitive. 
\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
Informally, two terms are $\alpha$-equivalent if they differ only by the names of the bound variables. Therefore, $\alpha$-equivalent terms have the same size, and the same set of free variables: 
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{lambda es.aeq size}{aeq\_size}{\coqdoclemma{aeq\_size}}: \coqdockw{\ensuremath{\forall}} \coqdef{lambda es.t1:148}{t1}{\coqdocbinder{t1}} \coqdef{lambda es.t2:149}{t2}{\coqdocbinder{t2}}, \coqref{lambda es.t1:148}{\coqdocvariable{t1}} \coqref{lambda es.:::x '=a' x}{\coqdocnotation{=}}\coqref{lambda es.:::x '=a' x}{\coqdocnotation{a}} \coqref{lambda es.t2:149}{\coqdocvariable{t2}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.size}{\coqdocdefinition{size}} \coqref{lambda es.t1:148}{\coqdocvariable{t1}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{lambda es.size}{\coqdocdefinition{size}} \coqref{lambda es.t2:149}{\coqdocvariable{t2}}.\coqdoceol
\coqdocnoindent
\coqdockw{Lemma} \coqdef{lambda es.aeq fv nom}{aeq\_fv\_nom}{\coqdoclemma{aeq\_fv\_nom}} : \coqdockw{\ensuremath{\forall}} \coqdef{lambda es.t1:150}{t1}{\coqdocbinder{t1}} \coqdef{lambda es.t2:151}{t2}{\coqdocbinder{t2}}, \coqref{lambda es.t1:150}{\coqdocvariable{t1}} \coqref{lambda es.:::x '=a' x}{\coqdocnotation{=}}\coqref{lambda es.:::x '=a' x}{\coqdocnotation{a}} \coqref{lambda es.t2:151}{\coqdocvariable{t2}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.fv nom}{\coqdocdefinition{fv\_nom}} \coqref{lambda es.t1:150}{\coqdocvariable{t1}} \coqdocnotation{[=]} \coqref{lambda es.fv nom}{\coqdocdefinition{fv\_nom}} \coqref{lambda es.t2:151}{\coqdocvariable{t2}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The key point of the nominal approach is that the swap operation is stable under $\alpha$-equivalence in the sense that, $t_1 =_\alpha t_2$ if, and only if $\swap{x}{y}{t_1} =_\alpha \swap{x}{y}{t_2}$. Note that this is not true for renaming substitutions: in fact, $\lambda_x.z =_\alpha \lambda_y.z$, but $(\lambda_x.z)\msub{z}{x} = \lambda_x.x \neq_\alpha \lambda_y.x (\lambda_y.z)\msub{z}{x}$, assuming that $x \neq y$. This stability result is formalized as follows: 
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Corollary} \coqdef{lambda es.aeq swap}{aeq\_swap}{\coqdoclemma{aeq\_swap}}: \coqdockw{\ensuremath{\forall}} \coqdef{lambda es.t1:163}{t1}{\coqdocbinder{t1}} \coqdef{lambda es.t2:164}{t2}{\coqdocbinder{t2}} \coqdef{lambda es.x:165}{x}{\coqdocbinder{x}} \coqdef{lambda es.y:166}{y}{\coqdocbinder{y}}, \coqref{lambda es.t1:163}{\coqdocvariable{t1}} \coqref{lambda es.:::x '=a' x}{\coqdocnotation{=}}\coqref{lambda es.:::x '=a' x}{\coqdocnotation{a}} \coqref{lambda es.t2:164}{\coqdocvariable{t2}} \coqexternalref{::type scope:x '<->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\leftrightarrow}}} \coqref{lambda es.:::x '=a' x}{\coqdocnotation{(}}\coqref{lambda es.swap}{\coqdocdefinition{swap}} \coqref{lambda es.x:165}{\coqdocvariable{x}} \coqref{lambda es.y:166}{\coqdocvariable{y}} \coqref{lambda es.t1:163}{\coqdocvariable{t1}}\coqref{lambda es.:::x '=a' x}{\coqdocnotation{)}} \coqref{lambda es.:::x '=a' x}{\coqdocnotation{=}}\coqref{lambda es.:::x '=a' x}{\coqdocnotation{a}} \coqref{lambda es.:::x '=a' x}{\coqdocnotation{(}}\coqref{lambda es.swap}{\coqdocdefinition{swap}} \coqref{lambda es.x:165}{\coqdocvariable{x}} \coqref{lambda es.y:166}{\coqdocvariable{y}} \coqref{lambda es.t2:164}{\coqdocvariable{t2}}\coqref{lambda es.:::x '=a' x}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
There are several interesting auxiliary properties that need to be proved before achieving the substitution lemma. In what follows, we refer only to the tricky or challenging ones, but the interested reader can have a detailed look in the source files. Note that, swaps are introduced in proofs by the rules $\mbox{\it aeq}\_\mbox{\it abs}\_\mbox{\it diff}$ and $\mbox{\it aeq}\_\mbox{\it sub}\_\mbox{\it diff}$. As we will see, the proof steps involving these rules are trick because a naïve strategy can easily result in a proofless branch. so that one can establish the $\alpha$-equivalence between two abstractions or two explicit substitutions with different binders. The following proposition states when two swaps with a common name collapse, and it is used in the transitivity proof of \coqdocvar{aeq}: 
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{lambda es.aeq swap swap}{aeq\_swap\_swap}{\coqdoclemma{aeq\_swap\_swap}}: \coqdockw{\ensuremath{\forall}} \coqdef{lambda es.t:195}{t}{\coqdocbinder{t}} \coqdef{lambda es.x:196}{x}{\coqdocbinder{x}} \coqdef{lambda es.y:197}{y}{\coqdocbinder{y}} \coqdef{lambda es.z:198}{z}{\coqdocbinder{z}}, \coqref{lambda es.z:198}{\coqdocvariable{z}} \coqdocnotation{`}\coqdocnotation{notin}\coqdocnotation{`} \coqref{lambda es.fv nom}{\coqdocdefinition{fv\_nom}} \coqref{lambda es.t:195}{\coqdocvariable{t}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.x:196}{\coqdocvariable{x}} \coqdocnotation{`}\coqdocnotation{notin}\coqdocnotation{`} \coqref{lambda es.fv nom}{\coqdocdefinition{fv\_nom}} \coqref{lambda es.t:195}{\coqdocvariable{t}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.:::x '=a' x}{\coqdocnotation{(}}\coqref{lambda es.swap}{\coqdocdefinition{swap}} \coqref{lambda es.z:198}{\coqdocvariable{z}} \coqref{lambda es.x:196}{\coqdocvariable{x}} (\coqref{lambda es.swap}{\coqdocdefinition{swap}} \coqref{lambda es.x:196}{\coqdocvariable{x}} \coqref{lambda es.y:197}{\coqdocvariable{y}} \coqref{lambda es.t:195}{\coqdocvariable{t}})\coqref{lambda es.:::x '=a' x}{\coqdocnotation{)}} \coqref{lambda es.:::x '=a' x}{\coqdocnotation{=}}\coqref{lambda es.:::x '=a' x}{\coqdocnotation{a}} \coqref{lambda es.:::x '=a' x}{\coqdocnotation{(}}\coqref{lambda es.swap}{\coqdocdefinition{swap}} \coqref{lambda es.z:198}{\coqdocvariable{z}} \coqref{lambda es.y:197}{\coqdocvariable{y}} \coqref{lambda es.t:195}{\coqdocvariable{t}}\coqref{lambda es.:::x '=a' x}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{The metasubstitution operation of the $\lambda$-calculus}



 The main operation of the $\lambda$-calculus is the $\beta$-reduction that express how to evaluate a function applied to a given argument: $(\lambda_x.t)\ u \to_{\beta} \metasub{t}{x}{u}$. In a less formal context, the concept of $\beta$-reduction means that the result of evaluating the function $(\lambda_x.t)$ with argument $u$ is obtained by substituting $u$ for the free ocurrences of the variable $x$ in $t$. Moreover, it is a capture free substitution in the sense that no free variable becomes bound after the substitution. This operation is in the meta level because it is outside the grammar of the $\lambda$-calculus, and that's why it is called metasubstitution. As a metaoperation, its definition usually comes with a degree of informality. For instance, Barendregt\cite{barendregtLambdaCalculusIts1984} defines it as follows: \vspace{.5cm}
$\metasub{t}{x}{u} = \left\{
 \begin{array}{ll}
  u, & \mbox{ if } t = x; \\
  y, & \mbox{ if } t = y \mbox{ and } x \neq y; \\
  \metasub{t_1}{x}{u}\ \metasub{t_2}{x}{u}, & \mbox{ if } t = \metasub{(t_1\ t_2)}{x}{u}; \\
  \lambda_y.(\metasub{t_1}{x}{u}), & \mbox{ if } t = \lambda_y.t_1.
 \end{array}\right.$ \vspace{.5cm}
\noindent where it is assumed the so called ``Barendregt's variable convention'': if $t_1, t_2, \ldots, t_n$ occur in a certain mathematical context (e.g. definition, proof), then in these terms all bound variables are chosen to be different from the free variables. This means that we are assumming that both $x \neq y$ and $y\notin fv(u)$ in the case $t = \lambda_y.t_1$. This approach is very convenient in informal proofs because it avoids having to rename bound variables. In order to formalize the capture free substitution of the $\lambda$-calculus, {\it i.e.} the metasubstitution, a renaming is performed whenever it is propagated inside a binder. In our case, there are two binders: the abstraction and the explicit substitution. 


Let $t$ and $u$ be terms, and $x$ a variable. The result of substituting $u$ for the free ocurrences of $x$ in $t$, written $t\msub{x}{u}$ is defined as follows:\newline
\begin{equation}\label{msubst}
\metasub{t}{x}{u} = \left\{
 \begin{array}{ll}
  u, & \mbox{ if } t = x; \\
  y, & \mbox{ if } t = y \mbox{ and } x \neq y; \\
  \metasub{t_1}{x}{u}\ \metasub{t_2}{x}{u}, & \mbox{ if } t = \metasub{(t_1\ t_2)}{x}{u}; \\
  \lambda_x.t_1, & \mbox{ if } t = \lambda_x.t_1; \\
  \lambda_z.(\metasub{(\swap{y}{z}{t_1})}{x}{u}), & \mbox{ if } t = \lambda_y.t_1, x \neq y \mbox{ and } z\notin fv(\lambda_y.t_1)\cup fv(u) \cup \{x\}; \\
  \esub{t_1}{x}{\metasub{t_2}{x}{u}}, & \mbox{ if } t = \esub{t_1}{x}{t_2}; \\
  \esub{\metasub{(\swap{y}{z}{t_1})}{x}{u}}{z}{\metasub{t_2}{x}{u}}, & \mbox{ if } t = \esub{t_1}{y}{t_2}, x \neq y \mbox{ and } z\notin fv(\esub{t_1}{y}{t_2})\cup fv(u) \cup \{x\}.
 \end{array}\right.
\end{equation}


Note that this function is not structurally recursive due to the swaps in the recursive calls. A structurally recursive version of the function \coqdocvar{subst\_rec\_fun} can be found in the file \coqdocvar{nominal.v} of the \coqdocvar{Metalib} library\footnote{\url{https://github.com/plclub/metalib}}, but it uses the size of the term in which the substitution will be performed as an extra argument that decreases with each recursive call. We write [\coqdocvar{x}:=\coqdocvar{u}]\coqdocvar{t} instead of \coqdocvar{subst\_rec\_fun} \coqdocvar{t} \coqdocvar{u} \coqdocvar{x} in the Coq code to represent $\metasub{t}{x}{u}$. The corresponding Coq code is as follows: 
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Function} \coqdocvar{subst\_rec\_fun} (\coqdef{lambda es.t:222}{t}{\coqdocbinder{t}}:\coqref{lambda es.n sexp}{\coqdocinductive{n\_sexp}}) (\coqdef{lambda es.u:223}{u}{\coqdocbinder{u}} :\coqref{lambda es.n sexp}{\coqdocinductive{n\_sexp}}) (\coqdef{lambda es.x:224}{x}{\coqdocbinder{x}}:\coqdocabbreviation{atom}) \{\coqdockw{measure} \coqref{lambda es.size}{\coqdocdefinition{size}} \coqdocvar{t}\} : \coqref{lambda es.n sexp}{\coqdocinductive{n\_sexp}} :=\coqdoceol
\coqdocindent{1.00em}
\coqdockw{match} \coqref{lambda es.t:199}{\coqdocvariable{t}} \coqdockw{with}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{lambda es.n var}{\coqdocconstructor{n\_var}} \coqdocvar{y} \ensuremath{\Rightarrow} \coqdockw{if} (\coqref{lambda es.x:201}{\coqdocvariable{x}} \coqdocnotation{==} \coqdocvar{y}) \coqdockw{then} \coqref{lambda es.u:200}{\coqdocvariable{u}} \coqdockw{else} \coqref{lambda es.t:199}{\coqdocvariable{t}}\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{lambda es.n abs}{\coqdocconstructor{n\_abs}} \coqdocvar{y} \coqdocvar{t1} \ensuremath{\Rightarrow} \coqdockw{if} (\coqref{lambda es.x:201}{\coqdocvariable{x}} \coqdocnotation{==} \coqdocvar{y}) \coqdockw{then} \coqref{lambda es.t:199}{\coqdocvariable{t}} \coqdockw{else} \coqdockw{let} (\coqdef{lambda es.z:226}{z}{\coqdocbinder{z}},\coqdocvar{\_}) :=\coqdoceol
\coqdocindent{2.00em}
\coqdoclemma{atom\_fresh} (\coqref{lambda es.fv nom}{\coqdocdefinition{fv\_nom}} \coqref{lambda es.u:200}{\coqdocvariable{u}} \coqdocnotation{`}\coqdocnotation{union}\coqdocnotation{`} \coqref{lambda es.fv nom}{\coqdocdefinition{fv\_nom}} \coqref{lambda es.t:199}{\coqdocvariable{t}} \coqdocnotation{`}\coqdocnotation{union}\coqdocnotation{`} \coqdocnotation{\{\{}\coqref{lambda es.x:201}{\coqdocvariable{x}}\coqdocnotation{\}\}}) \coqdoctac{in} \coqref{lambda es.n abs}{\coqdocconstructor{n\_abs}} \coqref{lambda es.z:204}{\coqdocvariable{z}} (\coqref{lambda es.subst rec fun:202}{\coqdocdefinition{subst\_rec\_fun}} (\coqref{lambda es.swap}{\coqdocdefinition{swap}} \coqdocvar{y} \coqref{lambda es.z:204}{\coqdocvariable{z}} \coqdocvar{t1}) \coqref{lambda es.u:200}{\coqdocvariable{u}} \coqref{lambda es.x:201}{\coqdocvariable{x}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{lambda es.n app}{\coqdocconstructor{n\_app}} \coqdocvar{t1} \coqdocvar{t2} \ensuremath{\Rightarrow} \coqref{lambda es.n app}{\coqdocconstructor{n\_app}} (\coqref{lambda es.subst rec fun:202}{\coqdocdefinition{subst\_rec\_fun}} \coqdocvar{t1} \coqref{lambda es.u:200}{\coqdocvariable{u}} \coqref{lambda es.x:201}{\coqdocvariable{x}}) (\coqref{lambda es.subst rec fun:202}{\coqdocdefinition{subst\_rec\_fun}} \coqdocvar{t2} \coqref{lambda es.u:200}{\coqdocvariable{u}} \coqref{lambda es.x:201}{\coqdocvariable{x}})\coqdoceol
\coqdocindent{1.00em}
\ensuremath{|} \coqref{lambda es.n sub}{\coqdocconstructor{n\_sub}} \coqdocvar{t1} \coqdocvar{y} \coqdocvar{t2} \ensuremath{\Rightarrow} \coqdockw{if} (\coqref{lambda es.x:201}{\coqdocvariable{x}} \coqdocnotation{==} \coqdocvar{y}) \coqdockw{then} \coqref{lambda es.n sub}{\coqdocconstructor{n\_sub}} \coqdocvar{t1} \coqdocvar{y} (\coqref{lambda es.subst rec fun:202}{\coqdocdefinition{subst\_rec\_fun}} \coqdocvar{t2} \coqref{lambda es.u:200}{\coqdocvariable{u}} \coqref{lambda es.x:201}{\coqdocvariable{x}}) \coqdockw{else} \coqdockw{let} (\coqdef{lambda es.z:227}{z}{\coqdocbinder{z}},\coqdocvar{\_}) :=\coqdoceol
\coqdocindent{2.00em}
\coqdoclemma{atom\_fresh} (\coqref{lambda es.fv nom}{\coqdocdefinition{fv\_nom}} \coqref{lambda es.u:200}{\coqdocvariable{u}} \coqdocnotation{`}\coqdocnotation{union}\coqdocnotation{`} \coqref{lambda es.fv nom}{\coqdocdefinition{fv\_nom}} \coqref{lambda es.t:199}{\coqdocvariable{t}} \coqdocnotation{`}\coqdocnotation{union}\coqdocnotation{`} \coqdocnotation{\{\{}\coqref{lambda es.x:201}{\coqdocvariable{x}}\coqdocnotation{\}\}}) \coqdoctac{in}\coqdoceol
\coqdocindent{2.00em}
\coqref{lambda es.n sub}{\coqdocconstructor{n\_sub}} (\coqref{lambda es.subst rec fun:202}{\coqdocdefinition{subst\_rec\_fun}} (\coqref{lambda es.swap}{\coqdocdefinition{swap}} \coqdocvar{y} \coqref{lambda es.z:205}{\coqdocvariable{z}} \coqdocvar{t1}) \coqref{lambda es.u:200}{\coqdocvariable{u}} \coqref{lambda es.x:201}{\coqdocvariable{x}}) \coqref{lambda es.z:205}{\coqdocvariable{z}} (\coqref{lambda es.subst rec fun:202}{\coqdocdefinition{subst\_rec\_fun}} \coqdocvar{t2} \coqref{lambda es.u:200}{\coqdocvariable{u}} \coqref{lambda es.x:201}{\coqdocvariable{x}}) \coqdoceol
\coqdocnoindent
\coqdockw{end}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
The standard proof strategy for the non trivial properties is induction on the structure of the terms. Nevertheless, the builtin induction principle automatically generated for the inductive definition \coqdocvar{n\_sexp} is not strong enough due to swappings. In fact, in general, the induction hypothesis in the abstraction case, for instance, refer to the body of the abstraction, while the goal involves a swap acting on the body of the abstraction. In order to circunvet this problem, we use an induction principle based on the size of terms: 
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{lambda es.n sexp induction}{n\_sexp\_induction}{\coqdoclemma{n\_sexp\_induction}}:\coqdoceol
\coqdocindent{0.50em}
\coqdockw{\ensuremath{\forall}} \coqdef{lambda es.P:304}{P}{\coqdocbinder{P}} : \coqref{lambda es.n sexp}{\coqdocinductive{n\_sexp}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdockw{Prop},\coqdoceol
\coqdocindent{0.50em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdef{lambda es.x:305}{x}{\coqdocbinder{x}}, \coqref{lambda es.P:304}{\coqdocvariable{P}} (\coqref{lambda es.n var}{\coqdocconstructor{n\_var}} \coqref{lambda es.x:305}{\coqdocvariable{x}})\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{0.50em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdef{lambda es.t1:306}{t1}{\coqdocbinder{t1}} \coqdef{lambda es.z:307}{z}{\coqdocbinder{z}}, \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdef{lambda es.t2:308}{t2}{\coqdocbinder{t2}} \coqdef{lambda es.x:309}{x}{\coqdocbinder{x}} \coqdef{lambda es.y:310}{y}{\coqdocbinder{y}}, \coqref{lambda es.size}{\coqdocdefinition{size}} \coqref{lambda es.t2:308}{\coqdocvariable{t2}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{lambda es.size}{\coqdocdefinition{size}} \coqref{lambda es.t1:306}{\coqdocvariable{t1}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.P:304}{\coqdocvariable{P}} (\coqref{lambda es.swap}{\coqdocdefinition{swap}} \coqref{lambda es.x:309}{\coqdocvariable{x}} \coqref{lambda es.y:310}{\coqdocvariable{y}} \coqref{lambda es.t2:308}{\coqdocvariable{t2}})\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.P:304}{\coqdocvariable{P}} (\coqref{lambda es.n abs}{\coqdocconstructor{n\_abs}} \coqref{lambda es.z:307}{\coqdocvariable{z}} \coqref{lambda es.t1:306}{\coqdocvariable{t1}})\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{0.50em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdef{lambda es.t1:311}{t1}{\coqdocbinder{t1}} \coqdef{lambda es.t2:312}{t2}{\coqdocbinder{t2}}, \coqref{lambda es.P:304}{\coqdocvariable{P}} \coqref{lambda es.t1:311}{\coqdocvariable{t1}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.P:304}{\coqdocvariable{P}} \coqref{lambda es.t2:312}{\coqdocvariable{t2}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.P:304}{\coqdocvariable{P}} (\coqref{lambda es.n app}{\coqdocconstructor{n\_app}} \coqref{lambda es.t1:311}{\coqdocvariable{t1}} \coqref{lambda es.t2:312}{\coqdocvariable{t2}})\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}}\coqdoceol
\coqdocindent{0.50em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdef{lambda es.t1:313}{t1}{\coqdocbinder{t1}} \coqdef{lambda es.t3:314}{t3}{\coqdocbinder{t3}} \coqdef{lambda es.z:315}{z}{\coqdocbinder{z}}, \coqref{lambda es.P:304}{\coqdocvariable{P}} \coqref{lambda es.t3:314}{\coqdocvariable{t3}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdef{lambda es.t2:316}{t2}{\coqdocbinder{t2}} \coqdef{lambda es.x:317}{x}{\coqdocbinder{x}} \coqdef{lambda es.y:318}{y}{\coqdocbinder{y}}, \coqref{lambda es.size}{\coqdocdefinition{size}} \coqref{lambda es.t2:316}{\coqdocvariable{t2}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{lambda es.size}{\coqdocdefinition{size}} \coqref{lambda es.t1:313}{\coqdocvariable{t1}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.P:304}{\coqdocvariable{P}} (\coqref{lambda es.swap}{\coqdocdefinition{swap}} \coqref{lambda es.x:317}{\coqdocvariable{x}} \coqref{lambda es.y:318}{\coqdocvariable{y}} \coqref{lambda es.t2:316}{\coqdocvariable{t2}})\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.P:304}{\coqdocvariable{P}} (\coqref{lambda es.n sub}{\coqdocconstructor{n\_sub}} \coqref{lambda es.t1:313}{\coqdocvariable{t1}} \coqref{lambda es.z:315}{\coqdocvariable{z}} \coqref{lambda es.t3:314}{\coqdocvariable{t3}})\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{)}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqdoceol
\coqdocindent{0.50em}
\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{(}}\coqdockw{\ensuremath{\forall}} \coqdef{lambda es.t:319}{t}{\coqdocbinder{t}}, \coqref{lambda es.P:304}{\coqdocvariable{P}} \coqref{lambda es.t:319}{\coqdocvariable{t}}\coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
The following lemma states that if $x \notin fv(t)$ then $\metasub{t}{x}{u} =_\alpha t$. In informal proofs the conclusion of this lemma is usually stated as a syntactic equality, {\i.e.} $\metasub{t}{x}{u} = t$ instead of the $\alpha$-equivalence, but due to the changes of the names of the bound variables when the metasubstitution is propagated inside an abstraction or inside an explicit substitution, syntactic equality does not hold here. 
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{lambda es.m subst notin}{m\_subst\_notin}{\coqdoclemma{m\_subst\_notin}}: \coqdockw{\ensuremath{\forall}} \coqdef{lambda es.t:323}{t}{\coqdocbinder{t}} \coqdef{lambda es.u:324}{u}{\coqdocbinder{u}} \coqdef{lambda es.x:325}{x}{\coqdocbinder{x}}, \coqref{lambda es.x:325}{\coqdocvariable{x}} \coqdocnotation{`}\coqdocnotation{notin}\coqdocnotation{`} \coqref{lambda es.fv nom}{\coqdocdefinition{fv\_nom}} \coqref{lambda es.t:323}{\coqdocvariable{t}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{[}}\coqref{lambda es.x:325}{\coqdocvariable{x}} \coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{:=}} \coqref{lambda es.u:324}{\coqdocvariable{u}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{]}}\coqref{lambda es.t:323}{\coqdocvariable{t}} \coqref{lambda es.:::x '=a' x}{\coqdocnotation{=}}\coqref{lambda es.:::x '=a' x}{\coqdocnotation{a}} \coqref{lambda es.t:323}{\coqdocvariable{t}}.\coqdoceol
\end{coqdoccode}
\noindent{\bf Proof.} The proof is done by induction on the size of the term \coqdocvar{t} using the \coqdocvar{n\_sexp\_induction} principle. One interesting case is when $t = \lambda_y.t_1$ and $x \neq y$. In this case, we have to prove that $(\lambda_y.t_1)\msub{x}{u} =_\alpha \lambda_y.t_1$. The induction hypothesis express the fact that every term with the same size as the body of the abstraction $t_1$ satisfies the property to be proven:


$\forall t'\ x\ y, |t'| = |t_1| \to \forall u\ x', x' \notin fv(\swap{x}{y}{t'}) \to (\swap{x}{y}{t'})\msub{x'}{u} =_\alpha \swap{x}{y}{t'}$.


Therefore, according to the function \coqdocvar{subst\_rec\_fun}, the variable $y$ will be renamed to a new name, say $z$, such that $z \notin fv(\lambda_y.t_1) \cup fv(u) \cup \{x\}$, and we have to prove that $\lambda_z.(\swap{z}{y}{t_1})\msub{x}{u} =_\alpha \lambda_y.t_1$. Since $z \notin fv(\lambda_y.t_1) = fv(t_1)\backslash \{y\}$, there are two cases:
 \begin{enumerate}
   \item $z = y$: In this case, we have to prove that $\lambda_z.(\swap{z}{z}{t_1})\msub{x}{u} =_\alpha \lambda_z.t_1$. By the rule $\mbox{\it aeq}\_\mbox{\it abs}\_\mbox{\it same}$ we get $(\swap{z}{z}{t_1})\msub{x}{u} =_\alpha t_1$, but in order to apply the induction hypothesis the body of the metasubstitution and the term in the right hand side need to be the same and both need to be a swap. For this reason, we use the transitivity of $\alpha$-equivalence with $\swap{z}{z}{t_1}$ as intermediate term. The first subcase is proved by the induction hypothesis, and the second one is proved by the reflexivity of $\alpha$-equivalence.
\item $z \neq y$: In this case, $x \notin fv(t)$ and we can apply the rule $\mbox{\it aeq}\_\mbox{\it abs}\_\mbox{\it diff}$. The new goal is $(\swap{z}{y}{t_1})\msub{x}{u} =_\alpha \swap{z}{y}{t_1}$ which holds by the induction hypothesis, since $|\swap{z}{y}{t_1}| = |t_1|$ and $x \notin fv(\swap{z}{y}{t_1})$ because $x \neq z$, $x \neq y$ and $x \notin fv(t)$.
  \end{enumerate}
 The explicit substitution case is also interesting, but it follows a similar strategy used in the abstraction case for $t_1$. For $t_2$ the result follows from the induction hypothesis. $\hfill\Box$ 
\begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
We will now prove some stability results for the metasubstitution w.r.t. $\alpha$-equivalence. More precisely, we will prove that if $t =_\alpha t'$ and $u =_\alpha u'$ then $\metasub{t}{x}{u} =_\alpha \metasub{t'}{x}{u'}$, where $x$ is any variable and $t, t', u$ and $u'$ are any \coqdocvar{n\_sexp} terms. This proof is split in two steps: firstly, we prove that if $u =_\alpha u'$ then $\metasub{t}{x}{u} =_\alpha \metasub{t}{x}{u'}, \forall x, t, u, u'$; secondly, we prove that if $t =_\alpha t'$ then $\metasub{t}{x}{u} =_\alpha \metasub{t'}{x}{u}, \forall x, t, t', u$. These two steps are then combined through the transitivity of the $\alpha$-equivalence relation. Nevertheless, this task were not straighforward. Let's follow the steps of our first trial.
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{lambda es.aeq m subst in trial}{aeq\_m\_subst\_in\_trial}{\coqdoclemma{aeq\_m\_subst\_in\_trial}}: \coqdockw{\ensuremath{\forall}} \coqdef{lambda es.t:330}{t}{\coqdocbinder{t}} \coqdef{lambda es.u:331}{u}{\coqdocbinder{u}} \coqdef{lambda es.u':332}{u'}{\coqdocbinder{u'}} \coqdef{lambda es.x:333}{x}{\coqdocbinder{x}}, \coqref{lambda es.u:331}{\coqdocvariable{u}} \coqref{lambda es.:::x '=a' x}{\coqdocnotation{=}}\coqref{lambda es.:::x '=a' x}{\coqdocnotation{a}} \coqref{lambda es.u':332}{\coqdocvariable{u'}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.:::x '=a' x}{\coqdocnotation{(}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{[}}\coqref{lambda es.x:333}{\coqdocvariable{x}} \coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{:=}} \coqref{lambda es.u:331}{\coqdocvariable{u}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{]}} \coqref{lambda es.t:330}{\coqdocvariable{t}}\coqref{lambda es.:::x '=a' x}{\coqdocnotation{)}} \coqref{lambda es.:::x '=a' x}{\coqdocnotation{=}}\coqref{lambda es.:::x '=a' x}{\coqdocnotation{a}} \coqref{lambda es.:::x '=a' x}{\coqdocnotation{(}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{[}}\coqref{lambda es.x:333}{\coqdocvariable{x}} \coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{:=}} \coqref{lambda es.u':332}{\coqdocvariable{u'}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{]}} \coqref{lambda es.t:330}{\coqdocvariable{t}}\coqref{lambda es.:::x '=a' x}{\coqdocnotation{)}}.\coqdoceol
\end{coqdoccode}
\noindent{\bf Proof.} The proof is done by induction on the size of the term \coqdocvar{t}.
\begin{coqdoccode}
\end{coqdoccode}
The interesting case is when \coqdocvar{t} is an abstraction, {\it i.e.} $t = \lambda_y.t_1$. We need to prove that $\metasub{(\lambda_y.t_1)}{x}{u} =_\alpha \metasub{(\lambda_y.t_1)}{x}{u'}$.
\begin{coqdoccode}
\end{coqdoccode}
If $x = y$ then the result is trivial.
\begin{coqdoccode}
\end{coqdoccode}
Suppose $x \neq y$. The metasubstitution will be propagated inside the abstraction on each side of the $\alpha$-equation, after generating a new name for each side. The new goal is then $\lambda_{x_0}.\metasub{(\swap{y}{x_0}{t_1})}{x}{u} =_\alpha \lambda_{x_1}.\metasub{(\swap{y}{x_1}{t_1})}{x}{u'}$, where $x_0 \notin fv(\lambda_y.t_1) \cup fv(u) \cup \{x\}$ and $x_1 \notin fv(\lambda_y.t_1) \cup fv(u') \cup \{x\}$. The variables $x_0$ and $x_1$ are either the same or different.
\begin{coqdoccode}
\end{coqdoccode}
In the former case the result is trivial because $u =_\alpha u'$. 
\begin{coqdoccode}
\end{coqdoccode}
In the latter case, $x_0 \neq x_1$ and we need to prove that $\metasub{(\swap{y}{x_0}{t_1})}{x}{u} =_\alpha \swap{x_0}{x_1}{(\metasub{(\swap{y}{x_1}{t_1})}{x}{u'})}$.
\begin{coqdoccode}
\end{coqdoccode}
Therefore, we need to propagate the swap over the metasubstitution before been able to apply the induction hypothesis. The propagation of the swap over the metasubstitution is stated by the following lemma:


\begin{lemma} Let $t,u$ be terms, and $x,y,z$ variables. Then
 $\swap{y}{z}{(\metasub{t}{x}{u})} =_\alpha \metasub{(\swap{y}{z}{t})}{\vswap{y}{z}{x}}{\swap{y}{z}{u}}$.
\end{lemma}


\noindent whose corresponding Coq version is given by: \newline 
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdef{lambda es.swap m subst}{swap\_m\_subst}{\coqdoclemma{swap\_m\_subst}}: \coqdockw{\ensuremath{\forall}} \coqdef{lambda es.t:334}{t}{\coqdocbinder{t}} \coqdef{lambda es.u:335}{u}{\coqdocbinder{u}} \coqdef{lambda es.x:336}{x}{\coqdocbinder{x}} \coqdef{lambda es.y:337}{y}{\coqdocbinder{y}} \coqdef{lambda es.z:338}{z}{\coqdocbinder{z}}, \coqref{lambda es.swap}{\coqdocdefinition{swap}} \coqref{lambda es.y:337}{\coqdocvariable{y}} \coqref{lambda es.z:338}{\coqdocvariable{z}} (\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{[}}\coqref{lambda es.x:336}{\coqdocvariable{x}} \coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{:=}} \coqref{lambda es.u:335}{\coqdocvariable{u}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{]}}\coqref{lambda es.t:334}{\coqdocvariable{t}}) \coqref{lambda es.:::x '=a' x}{\coqdocnotation{=}}\coqref{lambda es.:::x '=a' x}{\coqdocnotation{a}} \coqref{lambda es.:::x '=a' x}{\coqdocnotation{(}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{[(}}\coqref{lambda es.swap var}{\coqdocdefinition{swap\_var}} \coqref{lambda es.y:337}{\coqdocvariable{y}} \coqref{lambda es.z:338}{\coqdocvariable{z}} \coqref{lambda es.x:336}{\coqdocvariable{x}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{)}} \coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{:=}} \coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{(}}\coqref{lambda es.swap}{\coqdocdefinition{swap}} \coqref{lambda es.y:337}{\coqdocvariable{y}} \coqref{lambda es.z:338}{\coqdocvariable{z}} \coqref{lambda es.u:335}{\coqdocvariable{u}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{)]}} \coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{(}}\coqref{lambda es.swap}{\coqdocdefinition{swap}} \coqref{lambda es.y:337}{\coqdocvariable{y}} \coqref{lambda es.z:338}{\coqdocvariable{z}} \coqref{lambda es.t:334}{\coqdocvariable{t}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{)}}\coqref{lambda es.:::x '=a' x}{\coqdocnotation{)}}.\coqdoceol
\end{coqdoccode}
\noindent{\bf Proof.} The proof is by induction on the size of the term \coqdocvar{t}.
\begin{coqdoccode}
\end{coqdoccode}
The interesting case is the abstraction, where we need to prove that $\swap{y}{z}{(\metasub{(\lambda_w.t_1)}{x}{u})} =_\alpha \metasub{(\swap{y}{z}{\lambda_w.t_1})}{\vswap{y}{z}{x}}{\swap{y}{z}{u}}$. On the left hand side, we can propagate the metasubstitution over the abstraction in the case that $x \neq w$ (the other is straighforward) and the new goal after the propagation of the swap over the abstraction is $\lambda_{\vswap{y}{z}{w'}}.\swap{y}{z}{(\metasub{\swap{w}{w'}{t_1}}{x}{u})} =_\alpha \metasub{(\lambda_{\vswap{y}{z}{w}}.\swap{y}{z}{t_1})}{\vswap{y}{z}{x}}{\swap{y}{z}{u}}$, where $w' \notin fv(\lambda_w.t_1) \cup fv(u) \cup \{x\}$.
\begin{coqdoccode}
\end{coqdoccode}
Now we propagate the metasubstitution over the abstraction in the right hand side term. Since $x\neq w$, we get $\vswap{y}{z}{x} \neq \vswap{y}{z}{w}$ and a renaming is necessary. After the renaming to a new name, say $w''$, such that $w'' \notin fv(\lambda_{\vswap{y}{z}{w}}.\swap{y}{z}{t_1}) \cup fv(\swap{y}{z}{u}) \cup \{\vswap{y}{z}{x}\}$, we get the following goal $\lambda_{\vswap{y}{z}{w'}}.\swap{y}{z}{(\metasub{\swap{w}{w'}{t_1}}{x}{u})} =_\alpha \lambda_{w''}.\metasub{(\swap{w''}{\vswap{y}{z}{w}}{(\swap{y}{z}{t_1})})}{\vswap{y}{z}{x}}{\swap{y}{z}{u}}$. We consider two cases: either $w'' = \vswap{y}{z}{w'}$ or $w'' \neq \vswap{y}{z}{w'}$.
\begin{coqdoccode}
\end{coqdoccode}
In the former case, we can apply the rule $\mbox{\it aeq}\_\mbox{\it abs}\_\mbox{\it same}$ and we get $\swap{y}{z}{(\metasub{(\swap{w}{w'}{t_1})}{x}{u})} =_\alpha \metasub{(\swap{w''}{\vswap{y}{z}{w}}{(\swap{y}{z}{t_1})})}{\vswap{y}{z}{x}}{\swap{y}{z}{u}}$ that can be proved by the induction hypothesis.
\begin{coqdoccode}
\end{coqdoccode}
When $w'' \neq \vswap{y}{z}{w'}$, the application of the rule $\mbox{\it aeq}\_\mbox{\it abs}\_\mbox{\it diff}$ generates the goal $\swap{w''}{\vswap{y}{z}{w'}}{\swap{y}{z}{(\metasub{\swap{w}{w'}{t_1}}{x}{u})}} =_\alpha \metasub{(\swap{w''}{\vswap{y}{z}{w}}{(\swap{y}{z}{t_1})})}{\vswap{y}{z}{x}}{\swap{y}{z}{u}}$. We can use the induction hypothesis to propagate the swap inside the metasubstitution, and then we get an $\alpha$-equality with metasubstitution as main operation on both sides, and whose correspondent components are $\alpha$-equivalent. In a more abstract way, we have to prove an $\alpha$-equality of the form $\metasub{t}{x}{u} =_\alpha \metasub{t'}{x}{u'}$, where $t =_\alpha t'$ and $u =_\alpha u'$. The problem is that we cannot rewrite $\alpha$-equalities inside metasubstitution unless we prove some special lemmas stating the compatibilities between them using the \coqdockw{Equations} library or something similar. Alternatively, if we decide to analise the metasubtitution componentwise, {\it i.e.} as stated in a lemma similar to \coqdocvar{aeq\_m\_subst\_in\_trial}, we get a circular proof problem because both \coqdocvar{aeq\_m\_subst\_in\_trial} and \coqdocvar{swap\_m\_subst} depend on each other to be proved. We will present a solution that do not use any additional library, but it adds the following axiom to the formalization:
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Axiom} \coqdef{lambda es.Eq implies equality}{Eq\_implies\_equality}{\coqdocaxiom{Eq\_implies\_equality}}: \coqdockw{\ensuremath{\forall}} \coqdef{lambda es.s:339}{s}{\coqdocbinder{s}} \coqdef{lambda es.s':340}{s'}{\coqdocbinder{s'}}: \coqdocabbreviation{atoms}, \coqref{lambda es.s:339}{\coqdocvariable{s}} \coqdocnotation{[=]} \coqref{lambda es.s':340}{\coqdocvariable{s'}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.s:339}{\coqdocvariable{s}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{lambda es.s':340}{\coqdocvariable{s'}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
This axiom transform a set equality into a syntactic equality. This will allow us to rewrite sets of atoms in a more flexible way. To show how it works, we will start proving the lemma \coqdocvar{aeq\_m\_subst\_in} without the need of the lemma \coqdocvar{swap\_m\_subst}:
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{lambda es.aeq m subst in}{aeq\_m\_subst\_in}{\coqdoclemma{aeq\_m\_subst\_in}}: \coqdockw{\ensuremath{\forall}} \coqdef{lambda es.t:342}{t}{\coqdocbinder{t}} \coqdef{lambda es.u:343}{u}{\coqdocbinder{u}} \coqdef{lambda es.u':344}{u'}{\coqdocbinder{u'}} \coqdef{lambda es.x:345}{x}{\coqdocbinder{x}}, \coqref{lambda es.u:343}{\coqdocvariable{u}} \coqref{lambda es.:::x '=a' x}{\coqdocnotation{=}}\coqref{lambda es.:::x '=a' x}{\coqdocnotation{a}} \coqref{lambda es.u':344}{\coqdocvariable{u'}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.:::x '=a' x}{\coqdocnotation{(}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{[}}\coqref{lambda es.x:345}{\coqdocvariable{x}} \coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{:=}} \coqref{lambda es.u:343}{\coqdocvariable{u}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{]}} \coqref{lambda es.t:342}{\coqdocvariable{t}}\coqref{lambda es.:::x '=a' x}{\coqdocnotation{)}} \coqref{lambda es.:::x '=a' x}{\coqdocnotation{=}}\coqref{lambda es.:::x '=a' x}{\coqdocnotation{a}} \coqref{lambda es.:::x '=a' x}{\coqdocnotation{(}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{[}}\coqref{lambda es.x:345}{\coqdocvariable{x}} \coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{:=}} \coqref{lambda es.u':344}{\coqdocvariable{u'}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{]}} \coqref{lambda es.t:342}{\coqdocvariable{t}}\coqref{lambda es.:::x '=a' x}{\coqdocnotation{)}}.\coqdoceol
\end{coqdoccode}
\noindent{\bf Proof.} The proof is by induction on the size of the term \coqdocvar{t}.
\begin{coqdoccode}
\end{coqdoccode}
The interesting case is the abstraction. We have by hypothesis that $u =_\alpha u'$ therefore both $u$ and $u'$ have the same set of free variables by lemma \coqdocvar{aeq\_fv\_nom}. With the axiom \coqdocvar{Eq\_implies\_equality}, we can replace the set $fv(u)$ by $fv(u')$, or vice-versa, in such a way that instead of generating two new names for the propagation of the metasusbstitutions inside the abstractions, we need just one new name and there is no more the case where the binders of the abstractions were different names. 
\begin{coqdoccode}
\end{coqdoccode}
The case of the explicit substitution is similar, and with this strategy we avoid the rules $\mbox{\it aeq}\_\mbox{\it abs}\_\mbox{\it diff}$ and $\mbox{\it aeq}\_\mbox{\it sub}\_\mbox{\it diff}$ that introduce swappings. $\hfill\Box$
\begin{coqdoccode}
\end{coqdoccode}
\newline 
\begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
The next lemma, named \coqdocvar{aeq\_m\_subst\_out} will benefit the strategy used in the previous proof, but it is not straightfoward. In the proof below, we will mostly use Coq notation, instead of the metanotation of the previous proof. We believe that at this point of the work, even the readers not familiar with Coq, can easily understand the Coq code interleaved with metanotation. 
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdef{lambda es.aeq m subst out}{aeq\_m\_subst\_out}{\coqdoclemma{aeq\_m\_subst\_out}}: \coqdockw{\ensuremath{\forall}} \coqdef{lambda es.t:356}{t}{\coqdocbinder{t}} \coqdef{lambda es.t':357}{t'}{\coqdocbinder{t'}} \coqdef{lambda es.u:358}{u}{\coqdocbinder{u}} \coqdef{lambda es.x:359}{x}{\coqdocbinder{x}}, \coqref{lambda es.t:356}{\coqdocvariable{t}} \coqref{lambda es.:::x '=a' x}{\coqdocnotation{=}}\coqref{lambda es.:::x '=a' x}{\coqdocnotation{a}} \coqref{lambda es.t':357}{\coqdocvariable{t'}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.:::x '=a' x}{\coqdocnotation{(}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{[}}\coqref{lambda es.x:359}{\coqdocvariable{x}} \coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{:=}} \coqref{lambda es.u:358}{\coqdocvariable{u}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{]}} \coqref{lambda es.t:356}{\coqdocvariable{t}}\coqref{lambda es.:::x '=a' x}{\coqdocnotation{)}} \coqref{lambda es.:::x '=a' x}{\coqdocnotation{=}}\coqref{lambda es.:::x '=a' x}{\coqdocnotation{a}} \coqref{lambda es.:::x '=a' x}{\coqdocnotation{(}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{[}}\coqref{lambda es.x:359}{\coqdocvariable{x}} \coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{:=}} \coqref{lambda es.u:358}{\coqdocvariable{u}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{]}} \coqref{lambda es.t':357}{\coqdocvariable{t'}}\coqref{lambda es.:::x '=a' x}{\coqdocnotation{)}}.\coqdoceol
\end{coqdoccode}
\noindent{\bf Proof.} The proof is by induction on the size of the term \coqdocvar{t}. 
\begin{coqdoccode}
\end{coqdoccode}
The interesting case is the abstraction. The are two cases based on the definition of the $\alpha$-equivalence relation: either the binders have the same name or they are different. 
\begin{coqdoccode}
\end{coqdoccode}
In the former case, we have to prove  ([\coqdocvar{x} := \coqdocvar{u}] \coqdocvar{n\_abs} \coqdocvar{y} \coqdocvar{t1}) =\coqdocvar{a} ([\coqdocvar{x} := \coqdocvar{u}] \coqdocvar{n\_abs} \coqdocvar{y} \coqdocvar{t2}) assumming that \coqdocvar{t1} =\coqdocvar{a} \coqdocvar{t2}. In both sides of the $\alpha$-equation, the metasubstitutition need to be propagated over the abstraction, and according to our definition of metasubstitution, one name will be generated for each propagation. The new name to be generate for the term [\coqdocvar{x} := \coqdocvar{u}] (\coqdocvar{n\_abs} \coqdocvar{y} \coqdocvar{t1}) (lhs) is such that it is not in the set $fv(\lambda_y.t_1)\cup fv(u) \cup \{x\}$, while the new name to be generated for the term [\coqdocvar{x} := \coqdocvar{u}] (\coqdocvar{n\_abs} \coqdocvar{y} \coqdocvar{t2}) (rhs) is such that it is not in the set $fv(\lambda_y.t_2)\cup fv(u) \cup \{x\}$. Since \coqdocvar{t1} =\coqdocvar{a} \coqdocvar{t2}, by lemma \coqdocvar{aeq\_fv\_nom} the set of free variables of \coqdocvar{t1} is equal to the set of free variables of \coqdocvar{t2}, and therefore, we can generate just one new name for both propagations of the metasubstitution. 
\begin{coqdoccode}
\end{coqdoccode}
If this new name is \coqdocvar{x0} then the new goal to be proved is \coqdocvar{n\_abs} \coqdocvar{x0} (\coqdocvar{subst\_rec\_fun} (\coqdocvar{swap} \coqdocvar{y} \coqdocvar{x0} \coqdocvar{t1}) \coqdocvar{u} \coqdocvar{x}) =\coqdocvar{a} \coqdocvar{n\_abs} \coqdocvar{x0} (\coqdocvar{subst\_rec\_fun} (\coqdocvar{swap} \coqdocvar{y} \coqdocvar{x0} \coqdocvar{t2}) \coqdocvar{u} \coqdocvar{x}), which can be proved by the induction hypothesis. 
\begin{coqdoccode}
\end{coqdoccode}
If \coqdocvar{y} = \coqdocvar{x} then \coqdocvar{x} \ensuremath{\not=} \coqdocvar{y0} and the metasubstitution [\coqdocvar{x} := \coqdocvar{u}] has no effect on the LHS, but it can be propagated on the RHS, {\it i.e.} over the abstraction (\coqdocvar{n\_abs} \coqdocvar{y0} \coqdocvar{t2}) but it also has no effect in \coqdocvar{t2} because \coqdocvar{x} does not occur free in \coqdocvar{t2}. 
\begin{coqdoccode}
\end{coqdoccode}
If \coqdocvar{y} \ensuremath{\not=} \coqdocvar{x} then the metasubstitution can be propagated over the abstraction of the LHS, and similarly we compare \coqdocvar{x} with \coqdocvar{y0} to see what happens in the RHS. 
\begin{coqdoccode}
\end{coqdoccode}
When \coqdocvar{y0} = \coqdocvar{x} then the metasubstitution has no effect on the abstraction of the RHS. On the LHS the metasubstitution is propagated since \coqdocvar{y} \ensuremath{\not=} \coqdocvar{x} but, as in the previous case, it has no effect in \coqdocvar{t1} because \coqdocvar{y0} does not occur free in \coqdocvar{t1}.
\begin{coqdoccode}
\end{coqdoccode}
Now we have to prove that [\coqdocvar{x} := \coqdocvar{u}](\coqdocvar{n\_abs} \coqdocvar{y} \coqdocvar{t1}) =\coqdocvar{a} [\coqdocvar{x} := \coqdocvar{u}](\coqdocvar{n\_abs} \coqdocvar{y0} \coqdocvar{t2}), when \coqdocvar{y} \ensuremath{\not=} \coqdocvar{x}, \coqdocvar{y0} \ensuremath{\not=} \coqdocvar{x} and \coqdocvar{n\_abs} \coqdocvar{y} \coqdocvar{t1} =\coqdocvar{a} \coqdocvar{n\_abs} \coqdocvar{y0} \coqdocvar{t2}. Since the set of free variables of \coqdocvar{n\_abs} \coqdocvar{y} \coqdocvar{t1} is equal to the set of free variables of \coqdocvar{n\_abs} \coqdocvar{y0} \coqdocvar{t2}, we can as in the previous case generate only one new name, say \coqdocvar{x0} that fulfill the condition to propagate the metasubstitution on both sides of the $\alpha$-equation. More precisely, $x_0 \notin fv(\lambda_y.t1) \cup fv(u) \cup \{x\}$, and the goal to be proved is \coqdocvar{n\_abs} \coqdocvar{x0} ([\coqdocvar{x} := \coqdocvar{u}](\coqdocvar{swap} \coqdocvar{y} \coqdocvar{x0} \coqdocvar{t1})) =\coqdocvar{a} \coqdocvar{n\_abs} \coqdocvar{x0} ([\coqdocvar{x} := \coqdocvar{u}](\coqdocvar{swap} \coqdocvar{y0} \coqdocvar{x0} \coqdocvar{t2})).
\begin{coqdoccode}
\end{coqdoccode}
As just one new name was generated, there is no case where the binders of the abstractions are different. Remember that abstractions with different binders were the cause of the circularity problem in the proofs because the application of the rule \coqdocvar{aeq\_abs\_diff} introduces a new swap that will be outside the metasubstitution in this case, whose solution would require a lemma of the form of \coqdocvar{swap\_m\_subst}. Therefore, after an applycation of the rule \coqdocvar{aeq\_abs\_same}, we conclude with the induction hypothesis.
\begin{coqdoccode}
\end{coqdoccode}
The explicit substitution operation is also interesting, but the proof strategy is similar to the one used in the abstraction case. $\hfill\Box$
\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
As a corollary, one can join the lemmas \coqdocvar{aeq\_m\_subst\_in} and \coqdocvar{aeq\_m\_subst\_out} as follows:
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Corollary} \coqdef{lambda es.aeq m subst eq}{aeq\_m\_subst\_eq}{\coqdoclemma{aeq\_m\_subst\_eq}}: \coqdockw{\ensuremath{\forall}} \coqdef{lambda es.t:360}{t}{\coqdocbinder{t}} \coqdef{lambda es.t':361}{t'}{\coqdocbinder{t'}} \coqdef{lambda es.u:362}{u}{\coqdocbinder{u}} \coqdef{lambda es.u':363}{u'}{\coqdocbinder{u'}} \coqdef{lambda es.x:364}{x}{\coqdocbinder{x}}, \coqref{lambda es.t:360}{\coqdocvariable{t}} \coqref{lambda es.:::x '=a' x}{\coqdocnotation{=}}\coqref{lambda es.:::x '=a' x}{\coqdocnotation{a}} \coqref{lambda es.t':361}{\coqdocvariable{t'}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.u:362}{\coqdocvariable{u}} \coqref{lambda es.:::x '=a' x}{\coqdocnotation{=}}\coqref{lambda es.:::x '=a' x}{\coqdocnotation{a}} \coqref{lambda es.u':363}{\coqdocvariable{u'}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.:::x '=a' x}{\coqdocnotation{(}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{[}}\coqref{lambda es.x:364}{\coqdocvariable{x}} \coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{:=}} \coqref{lambda es.u:362}{\coqdocvariable{u}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{]}} \coqref{lambda es.t:360}{\coqdocvariable{t}}\coqref{lambda es.:::x '=a' x}{\coqdocnotation{)}} \coqref{lambda es.:::x '=a' x}{\coqdocnotation{=}}\coqref{lambda es.:::x '=a' x}{\coqdocnotation{a}} \coqref{lambda es.:::x '=a' x}{\coqdocnotation{(}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{[}}\coqref{lambda es.x:364}{\coqdocvariable{x}} \coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{:=}} \coqref{lambda es.u':363}{\coqdocvariable{u'}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{]}} \coqref{lambda es.t':361}{\coqdocvariable{t'}}\coqref{lambda es.:::x '=a' x}{\coqdocnotation{)}}.\coqdoceol
\coqdocemptyline
\end{coqdoccode}
Now, we show how to propagated a swap inside metasubstitutions using the decomposition of the metasubstitution provided by the corollary \coqdocvar{aeq\_m\_subst\_eq}.\newline 
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{lambda es.swap subst rec fun}{swap\_subst\_rec\_fun}{\coqdoclemma{swap\_subst\_rec\_fun}}: \coqdockw{\ensuremath{\forall}} \coqdef{lambda es.x:365}{x}{\coqdocbinder{x}} \coqdef{lambda es.y:366}{y}{\coqdocbinder{y}} \coqdef{lambda es.z:367}{z}{\coqdocbinder{z}} \coqdef{lambda es.t:368}{t}{\coqdocbinder{t}} \coqdef{lambda es.u:369}{u}{\coqdocbinder{u}}, \coqref{lambda es.swap}{\coqdocdefinition{swap}} \coqref{lambda es.x:365}{\coqdocvariable{x}} \coqref{lambda es.y:366}{\coqdocvariable{y}} (\coqref{lambda es.subst rec fun}{\coqdoclemma{subst\_rec\_fun}} \coqref{lambda es.t:368}{\coqdocvariable{t}} \coqref{lambda es.u:369}{\coqdocvariable{u}} \coqref{lambda es.z:367}{\coqdocvariable{z}}) \coqref{lambda es.:::x '=a' x}{\coqdocnotation{=}}\coqref{lambda es.:::x '=a' x}{\coqdocnotation{a}} \coqref{lambda es.subst rec fun}{\coqdoclemma{subst\_rec\_fun}} (\coqref{lambda es.swap}{\coqdocdefinition{swap}} \coqref{lambda es.x:365}{\coqdocvariable{x}} \coqref{lambda es.y:366}{\coqdocvariable{y}} \coqref{lambda es.t:368}{\coqdocvariable{t}}) (\coqref{lambda es.swap}{\coqdocdefinition{swap}} \coqref{lambda es.x:365}{\coqdocvariable{x}} \coqref{lambda es.y:366}{\coqdocvariable{y}} \coqref{lambda es.u:369}{\coqdocvariable{u}}) (\coqref{lambda es.swap var}{\coqdocdefinition{swap\_var}} \coqref{lambda es.x:365}{\coqdocvariable{x}} \coqref{lambda es.y:366}{\coqdocvariable{y}} \coqref{lambda es.z:367}{\coqdocvariable{z}}).\coqdoceol
\end{coqdoccode}
\noindent{\bf Proof.} Firstly, we compare \coqdocvar{x} and \coqdocvar{y}, since the case \coqdocvar{x} = \coqdocvar{y} is trivial.
\begin{coqdoccode}
\end{coqdoccode}
The proof proceeds by induction on the size of the term \coqdocvar{t}, assuming that \coqdocvar{x} \ensuremath{\not=} \coqdocvar{y}. The tricky cases are the abstraction and explicit substitution. 
\begin{coqdoccode}
\end{coqdoccode}
In the abstraction case, {\it i.e.} when $t = \lambda_{y'}.t_1$ then we must prove that \coqdocvar{swap} \coqdocvar{x} \coqdocvar{y} ([\coqdocvar{z} := \coqdocvar{u}](\coqdocvar{n\_abs} \coqdocvar{y'} \coqdocvar{t1})) =\coqdocvar{a} [(\coqdocvar{swap\_var} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z}) := (\coqdocvar{swap} \coqdocvar{x} \coqdocvar{y} \coqdocvar{u})](\coqdocvar{swap} \coqdocvar{x} \coqdocvar{y} (\coqdocvar{n\_abs} \coqdocvar{y'} \coqdocvar{t1})), and the induction hypothesis states that a swap can be propagated inside a metasubstitution whose body is a term with the same size as \coqdocvar{t1}. Firstly, we compare the variables \coqdocvar{y'} and \coqdocvar{z} to check whether we should propagate the metasubstitution inside the abstraction of the LHS. 
\begin{coqdoccode}
\end{coqdoccode}
When \coqdocvar{y'} = \coqdocvar{z} the metasubstitution is erased according to the definition (\ref{msubst}) on both sides of the $\alpha$-equation and we are done.
\begin{coqdoccode}
\end{coqdoccode}
When \coqdocvar{y'} \ensuremath{\not=} \coqdocvar{z} then the metasubstitutions on both sides of the $\alpha$-equation need to be propagated inside the corresponding abstractions. In order to do so, a new name need to be created. Note that in this case, it is not possible to create a unique name for both sides because the name of the LHS cannot belong to the set $fv(\lambda_y'.t_1) \cup fv(u) \cup \{z\}$, while the name of the RHS cannot belong to the set $fv(\swap{x}{y}{\lambda_y'.t_1}) \cup fv(\swap{x}{y}{u}) \cup \{\vswap{x}{y}{z}\}$.
\begin{coqdoccode}
\end{coqdoccode}
Let \coqdocvar{x0} be a new name that is not in the set $fv(\lambda_y'.t_1) \cup fv(u) \cup \{z\}$, and \coqdocvar{x1} a new name that is not in the set $fv(\swap{x}{y}{\lambda_y'.t_1}) \cup fv(\swap{x}{y}{u}) \cup \{\vswap{x}{y}{z}\}$. After renaming and propagating the metasubstitutions inside the abstractions, the current goal is \coqdocvar{n\_abs} (\coqdocvar{swap\_var} \coqdocvar{x} \coqdocvar{y} \coqdocvar{x0}) (\coqdocvar{swap} \coqdocvar{x} \coqdocvar{y} ([\coqdocvar{z} := \coqdocvar{u}](\coqdocvar{swap} \coqdocvar{y'} \coqdocvar{x0} \coqdocvar{t1}))) =\coqdocvar{a} \coqdocvar{n\_abs} \coqdocvar{x1} ([(\coqdocvar{swap\_var} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z}) := (\coqdocvar{swap} \coqdocvar{x} \coqdocvar{y} \coqdocvar{u})](\coqdocvar{swap} (\coqdocvar{swap\_var} \coqdocvar{x} \coqdocvar{y} \coqdocvar{y'}) \coqdocvar{x1} (\coqdocvar{swap} \coqdocvar{x} \coqdocvar{y} \coqdocvar{t1}))). We proceed by comparing \coqdocvar{x1} with (\coqdocvar{swap\_var} \coqdocvar{x} \coqdocvar{y} \coqdocvar{x0}).
\begin{coqdoccode}
\end{coqdoccode}
If \coqdocvar{x1} = (\coqdocvar{swap\_var} \coqdocvar{x} \coqdocvar{y} \coqdocvar{x0}) then we use the induction hypothesis to propagate the swap inside the metasubstitution in the LHS and the current goal is [(\coqdocvar{swap\_var} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z}) := (\coqdocvar{swap} \coqdocvar{x} \coqdocvar{y} \coqdocvar{u})](\coqdocvar{swap} \coqdocvar{x} \coqdocvar{y} (\coqdocvar{swap} \coqdocvar{y'} \coqdocvar{x0} \coqdocvar{t1})) =\coqdocvar{a}
  [(\coqdocvar{swap\_var} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z}) := (\coqdocvar{swap} \coqdocvar{x} \coqdocvar{y} \coqdocvar{u})](\coqdocvar{swap} (\coqdocvar{swap\_var} \coqdocvar{x} \coqdocvar{y} \coqdocvar{y'}) (\coqdocvar{swap\_var} \coqdocvar{x} \coqdocvar{y} \coqdocvar{x0}) (\coqdocvar{swap} \coqdocvar{x} \coqdocvar{y} \coqdocvar{t1})) that is proved by the swap equivariance lemma \coqdocvar{swap\_equivariance}.
\begin{coqdoccode}
\end{coqdoccode}
If \coqdocvar{x1} \ensuremath{\not=} (\coqdocvar{swap\_var} \coqdocvar{x} \coqdocvar{y} \coqdocvar{x0}) then by the rule \coqdocvar{aeq\_abs\_diff} we have to prove that the variable \coqdocvar{swap\_var} \coqdocvar{x} \coqdocvar{y} \coqdocvar{x0} is not in the set of free variables of the term [(\coqdocvar{swap\_var} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z}) := (\coqdocvar{swap} \coqdocvar{x} \coqdocvar{y} \coqdocvar{u})](\coqdocvar{swap} (\coqdocvar{swap\_var} \coqdocvar{x} \coqdocvar{y} \coqdocvar{y'}) \coqdocvar{x1} (\coqdocvar{swap} \coqdocvar{x} \coqdocvar{y} \coqdocvar{t1})) and that \coqdocvar{swap} \coqdocvar{x} \coqdocvar{y} ([\coqdocvar{z} := \coqdocvar{u}](\coqdocvar{swap} \coqdocvar{y'} \coqdocvar{x0} \coqdocvar{t1})) =\coqdocvar{a}
  \coqdocvar{swap} \coqdocvar{x1} (\coqdocvar{swap\_var} \coqdocvar{x} \coqdocvar{y'} \coqdocvar{x0}) ([(\coqdocvar{swap\_var} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z}) := (\coqdocvar{swap} \coqdocvar{x} \coqdocvar{y'} \coqdocvar{u})](\coqdocvar{swap} (\coqdocvar{swap\_var} \coqdocvar{x} \coqdocvar{y'} \coqdocvar{y}) \coqdocvar{x1} (\coqdocvar{swap} \coqdocvar{x} \coqdocvar{y'} \coqdocvar{t1}))).
\begin{coqdoccode}
\end{coqdoccode}
The former condition is routine.
\begin{coqdoccode}
\end{coqdoccode}
The later condition is proved using the induction hypothesis twice to propagate the swaps inside the metasubstitutions on each side of the $\alpha$-equality. This swap has no effect on the variable of the metasubstitution, therefore we can apply lemma \coqdocvar{aeq\_m\_subst\_eq} and each generated case is proved by routine manipulation of swaps.
\begin{coqdoccode}
\end{coqdoccode}
The case of the explicit substitution follows a similar strategy of the abstraction. The initial goal is to prove that \coqdocvar{swap} \coqdocvar{x} \coqdocvar{y} ([\coqdocvar{z} := \coqdocvar{u}](\coqdocvar{n\_sub} \coqdocvar{t1} \coqdocvar{y'} \coqdocvar{t2})) =\coqdocvar{a} [(\coqdocvar{swap\_var} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z}) := (\coqdocvar{swap} \coqdocvar{x} \coqdocvar{y} \coqdocvar{u})](\coqdocvar{swap} \coqdocvar{x} \coqdocvar{y} (\coqdocvar{n\_sub} \coqdocvar{t1} \coqdocvar{y'} \coqdocvar{t2})) and we start comparing the variables \coqdocvar{y'} and \coqdocvar{z}.
\begin{coqdoccode}
\end{coqdoccode}
When \coqdocvar{y'} = \coqdocvar{z}, the metasubstitution has no effect on the body of the metasubstitution but it can still be propagated to the term \coqdocvar{t2}. Therefore, this case is proved using the induction hypothesis over \coqdocvar{t2}. 
\begin{coqdoccode}
\end{coqdoccode}
When \coqdocvar{y'} \ensuremath{\not=} \coqdocvar{z}, then the metasubstitutions are propagated on both sides of the $\alpha$-equation. Analogously to the abstraction case, one new name for each propagation is necessary. Let \coqdocvar{x0} be a new name not in the set $fv(\esub{t1}{y'}{t2})\cup fv(u) \cup \{z\}$, and \coqdocvar{x1}, a new name not in the set $fv(\esub{\swap{x}{y}{t1}}{\vswap{x}{y}{y'}}{\swap{x}{y}{t2}})\cup fv(\swap{x}{y}{u}) \cup \{\vswap{x}{y}{z}\}$. After the propagation step, we have the goal \coqdocvar{n\_sub} (\coqdocvar{swap} \coqdocvar{x} \coqdocvar{y} ([\coqdocvar{z} := \coqdocvar{u}](\coqdocvar{swap} \coqdocvar{y'} \coqdocvar{x0} \coqdocvar{t1}))) (\coqdocvar{swap\_var} \coqdocvar{x} \coqdocvar{y} \coqdocvar{x0}) (\coqdocvar{swap} \coqdocvar{x} \coqdocvar{y} ([\coqdocvar{z} := \coqdocvar{u}]\coqdocvar{t2})) =\coqdocvar{a}
  \coqdocvar{n\_sub} ([(\coqdocvar{swap\_var} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z}) := (\coqdocvar{swap} \coqdocvar{x} \coqdocvar{y} \coqdocvar{u})](\coqdocvar{swap} (\coqdocvar{swap\_var} \coqdocvar{x} \coqdocvar{y} \coqdocvar{y'}) \coqdocvar{x1} (\coqdocvar{swap} \coqdocvar{x} \coqdocvar{y} \coqdocvar{t1}))) \coqdocvar{x1}
    ([(\coqdocvar{swap\_var} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z}) := (\coqdocvar{swap} \coqdocvar{x} \coqdocvar{y} \coqdocvar{u})](\coqdocvar{swap} \coqdocvar{x} \coqdocvar{y} \coqdocvar{t2})). We proceed by comparing \coqdocvar{x1} and (\coqdocvar{swap} \coqdocvar{x} \coqdocvar{y} \coqdocvar{x0}).
\begin{coqdoccode}
\end{coqdoccode}
If \coqdocvar{x1} = \coqdocvar{swap\_var} \coqdocvar{x} \coqdocvar{y} \coqdocvar{x0} then after an application of the rule \coqdocvar{aeq\_sub\_same}, each component of the explicit substitution is proved by the induction hypothesis.
\begin{coqdoccode}
\end{coqdoccode}
If \coqdocvar{x1} \ensuremath{\not=} \coqdocvar{swap\_var} \coqdocvar{x} \coqdocvar{y} \coqdocvar{x0} then we apply the rule \coqdocvar{aeq\_sub\_diff} to decompose the explicit substitution in its components. The second component is straightforward  by the induction hypothesis.
\begin{coqdoccode}
\end{coqdoccode}
The first component follows the strategy used in the abstraction case. The current goal, obtained after the application of the rule \coqdocvar{aeq\_sub\_diff} is \coqdocvar{swap} \coqdocvar{x} \coqdocvar{y} ([\coqdocvar{z} := \coqdocvar{u}](\coqdocvar{swap} \coqdocvar{y'} \coqdocvar{x0} \coqdocvar{t1})) =\coqdocvar{a}
  \coqdocvar{swap} \coqdocvar{x1} (\coqdocvar{swap\_var} \coqdocvar{x} \coqdocvar{y} \coqdocvar{x0}) ([(\coqdocvar{swap\_var} \coqdocvar{x} \coqdocvar{y} \coqdocvar{z}) := (\coqdocvar{swap} \coqdocvar{x} \coqdocvar{y} \coqdocvar{u})](\coqdocvar{swap} (\coqdocvar{swap\_var} \coqdocvar{x} \coqdocvar{y} \coqdocvar{y'}) \coqdocvar{x1} (\coqdocvar{swap} \coqdocvar{x} \coqdocvar{y} \coqdocvar{t1}))). The induction hypothesis is used twice to propagate the swap on both the LHS and RHS of the $\alpha$-equality. This swap has no effect on the variable of the metasubstitution, therefore we can apply lemma \coqdocvar{aeq\_m\_subst\_eq} and each generated case is proved by routine manipulation of swaps. $\hfill\Box$
\begin{coqdoccode}
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
The following lemmas state, respectively, what hapens when the variable in the meta-substitution is equal or different from the one in the abstraction. When it is equal, the meta-substitution is irrelevant. When they are different, we take a new variable that does not occur freely in the substituted term in the meta-substitution nor in the abstraction and is not the variable in the meta-substitution, and the abstraction of this new variable using the meta-substitution of the swap of the former variable in the meta-substitution is alpha-equivalent to the original meta-substitution of the abstraction. The proofs were straightforward from the definition of the meta-substitution, each case being respectively each one in the definition. \newline
\begin{coqdoccode}
\coqdocnoindent
\coqdockw{Lemma} \coqdef{lambda es.m subst abs eq}{m\_subst\_abs\_eq}{\coqdoclemma{m\_subst\_abs\_eq}} : \coqdockw{\ensuremath{\forall}} \coqdef{lambda es.u:375}{u}{\coqdocbinder{u}} \coqdef{lambda es.x:376}{x}{\coqdocbinder{x}} \coqdef{lambda es.t:377}{t}{\coqdocbinder{t}}, \coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{[}}\coqref{lambda es.x:376}{\coqdocvariable{x}} \coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{:=}} \coqref{lambda es.u:375}{\coqdocvariable{u}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{](}}\coqref{lambda es.n abs}{\coqdocconstructor{n\_abs}} \coqref{lambda es.x:376}{\coqdocvariable{x}} \coqref{lambda es.t:377}{\coqdocvariable{t}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{lambda es.n abs}{\coqdocconstructor{n\_abs}} \coqref{lambda es.x:376}{\coqdocvariable{x}} \coqref{lambda es.t:377}{\coqdocvariable{t}}.\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{lambda es.m subst abs neq}{m\_subst\_abs\_neq}{\coqdoclemma{m\_subst\_abs\_neq}} : \coqdockw{\ensuremath{\forall}} \coqdef{lambda es.t:378}{t}{\coqdocbinder{t}} \coqdef{lambda es.u:379}{u}{\coqdocbinder{u}} \coqdef{lambda es.x:380}{x}{\coqdocbinder{x}} \coqdef{lambda es.y:381}{y}{\coqdocbinder{y}} \coqdef{lambda es.z:382}{z}{\coqdocbinder{z}}, \coqref{lambda es.x:380}{\coqdocvariable{x}} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqref{lambda es.y:381}{\coqdocvariable{y}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.z:382}{\coqdocvariable{z}} \coqdocnotation{`}\coqdocnotation{notin}\coqdocnotation{`} \coqref{lambda es.fv nom}{\coqdocdefinition{fv\_nom}} \coqref{lambda es.u:379}{\coqdocvariable{u}} \coqdocnotation{`}\coqdocnotation{union}\coqdocnotation{`} \coqref{lambda es.fv nom}{\coqdocdefinition{fv\_nom}} (\coqref{lambda es.n abs}{\coqdocconstructor{n\_abs}} \coqref{lambda es.y:381}{\coqdocvariable{y}} \coqref{lambda es.t:378}{\coqdocvariable{t}}) \coqdocnotation{`}\coqdocnotation{union}\coqdocnotation{`} \coqdocnotation{\{\{}\coqref{lambda es.x:380}{\coqdocvariable{x}}\coqdocnotation{\}\}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{[}}\coqref{lambda es.x:380}{\coqdocvariable{x}} \coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{:=}} \coqref{lambda es.u:379}{\coqdocvariable{u}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{](}}\coqref{lambda es.n abs}{\coqdocconstructor{n\_abs}} \coqref{lambda es.y:381}{\coqdocvariable{y}} \coqref{lambda es.t:378}{\coqdocvariable{t}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{)}} \coqref{lambda es.:::x '=a' x}{\coqdocnotation{=}}\coqref{lambda es.:::x '=a' x}{\coqdocnotation{a}} \coqref{lambda es.n abs}{\coqdocconstructor{n\_abs}} \coqref{lambda es.z:382}{\coqdocvariable{z}} (\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{[}}\coqref{lambda es.x:380}{\coqdocvariable{x}} \coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{:=}} \coqref{lambda es.u:379}{\coqdocvariable{u}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{](}}\coqref{lambda es.swap}{\coqdocdefinition{swap}} \coqref{lambda es.y:381}{\coqdocvariable{y}} \coqref{lambda es.z:382}{\coqdocvariable{z}} \coqref{lambda es.t:378}{\coqdocvariable{t}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{)}}).\coqdoceol
\coqdocemptyline
\coqdocemptyline
\end{coqdoccode}
The following lemmas are the equivalent version of the two previous lemmas for the case of the explicit substitution. They state, respectively, what hapens when the variable in the meta-substitution is equal or different from the one in the explicit substitution. When it is equal, the meta-substitution is irrelevant on \coqdocvar{t1}, but it is applied to \coqdocvar{e2}. When they are different, we take a new variable that does not occur freely in the substituted term in the meta-substitution nor in the substitution and is not the variable in the meta-substitution, and the explicit substitution of this new variable using the meta-substitution of the swap of the former variable in the meta-substitution in \coqdocvar{e11} and the application of the original meta\_substitution in \coqdocvar{e12} is alpha-equivalent to the original meta-substitution of the explicit substitution. The proofs are straighforward from the definition of the meta-substitution, each case being respectively each one in the definition. \newline
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{lambda es.m subst sub eq}{m\_subst\_sub\_eq}{\coqdoclemma{m\_subst\_sub\_eq}} : \coqdockw{\ensuremath{\forall}} \coqdef{lambda es.u:389}{u}{\coqdocbinder{u}} \coqdef{lambda es.x:390}{x}{\coqdocbinder{x}} \coqdef{lambda es.t1:391}{t1}{\coqdocbinder{t1}} \coqdef{lambda es.t2:392}{t2}{\coqdocbinder{t2}}, \coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{[}}\coqref{lambda es.x:390}{\coqdocvariable{x}} \coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{:=}} \coqref{lambda es.u:389}{\coqdocvariable{u}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{](}}\coqref{lambda es.n sub}{\coqdocconstructor{n\_sub}} \coqref{lambda es.t1:391}{\coqdocvariable{t1}} \coqref{lambda es.x:390}{\coqdocvariable{x}} \coqref{lambda es.t2:392}{\coqdocvariable{t2}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{)}} \coqexternalref{::type scope:x '=' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{=}} \coqref{lambda es.n sub}{\coqdocconstructor{n\_sub}} \coqref{lambda es.t1:391}{\coqdocvariable{t1}} \coqref{lambda es.x:390}{\coqdocvariable{x}} (\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{[}}\coqref{lambda es.x:390}{\coqdocvariable{x}} \coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{:=}} \coqref{lambda es.u:389}{\coqdocvariable{u}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{]}} \coqref{lambda es.t2:392}{\coqdocvariable{t2}}).\coqdoceol
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{lambda es.m subst sub neq}{m\_subst\_sub\_neq}{\coqdoclemma{m\_subst\_sub\_neq}} : \coqdockw{\ensuremath{\forall}} \coqdef{lambda es.t1:393}{t1}{\coqdocbinder{t1}} \coqdef{lambda es.t2:394}{t2}{\coqdocbinder{t2}} \coqdef{lambda es.u:395}{u}{\coqdocbinder{u}} \coqdef{lambda es.x:396}{x}{\coqdocbinder{x}} \coqdef{lambda es.y:397}{y}{\coqdocbinder{y}} \coqdef{lambda es.z:398}{z}{\coqdocbinder{z}}, \coqref{lambda es.x:396}{\coqdocvariable{x}} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqref{lambda es.y:397}{\coqdocvariable{y}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.z:398}{\coqdocvariable{z}} \coqdocnotation{`}\coqdocnotation{notin}\coqdocnotation{`} \coqref{lambda es.fv nom}{\coqdocdefinition{fv\_nom}} \coqref{lambda es.u:395}{\coqdocvariable{u}} \coqdocnotation{`}\coqdocnotation{union}\coqdocnotation{`} \coqref{lambda es.fv nom}{\coqdocdefinition{fv\_nom}} (\coqref{lambda es.n sub}{\coqdocconstructor{n\_sub}} \coqref{lambda es.t1:393}{\coqdocvariable{t1}} \coqref{lambda es.y:397}{\coqdocvariable{y}} \coqref{lambda es.t2:394}{\coqdocvariable{t2}}) \coqdocnotation{`}\coqdocnotation{union}\coqdocnotation{`} \coqdocnotation{\{\{}\coqref{lambda es.x:396}{\coqdocvariable{x}}\coqdocnotation{\}\}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{[}}\coqref{lambda es.x:396}{\coqdocvariable{x}} \coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{:=}} \coqref{lambda es.u:395}{\coqdocvariable{u}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{](}}\coqref{lambda es.n sub}{\coqdocconstructor{n\_sub}} \coqref{lambda es.t1:393}{\coqdocvariable{t1}} \coqref{lambda es.y:397}{\coqdocvariable{y}} \coqref{lambda es.t2:394}{\coqdocvariable{t2}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{)}} \coqref{lambda es.:::x '=a' x}{\coqdocnotation{=}}\coqref{lambda es.:::x '=a' x}{\coqdocnotation{a}} \coqref{lambda es.n sub}{\coqdocconstructor{n\_sub}} (\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{[}}\coqref{lambda es.x:396}{\coqdocvariable{x}} \coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{:=}} \coqref{lambda es.u:395}{\coqdocvariable{u}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{](}}\coqref{lambda es.swap}{\coqdocdefinition{swap}} \coqref{lambda es.y:397}{\coqdocvariable{y}} \coqref{lambda es.z:398}{\coqdocvariable{z}} \coqref{lambda es.t1:393}{\coqdocvariable{t1}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{)}}) \coqref{lambda es.z:398}{\coqdocvariable{z}} (\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{[}}\coqref{lambda es.x:396}{\coqdocvariable{x}} \coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{:=}} \coqref{lambda es.u:395}{\coqdocvariable{u}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{]}}\coqref{lambda es.t2:394}{\coqdocvariable{t2}}).\coqdoceol
\coqdocemptyline
\end{coqdoccode}
\section{The substitution lemma for the metasubstitution}



 In the pure $\lambda$-calculus, the substitution lemma is probably the first non trivial property. In our framework, we have defined two different substitution operation, namely, the metasubstitution denoted by [\coqdocvar{x}:=\coqdocvar{u}]\coqdocvar{t} and the explicit substitution that has \coqdocvar{n\_sub} as a constructor. In what follows, we present the main steps of our proof of the substitution lemma for the metasubstitution operation: 
\begin{coqdoccode}
\coqdocemptyline
\coqdocnoindent
\coqdockw{Lemma} \coqdef{lambda es.m subst lemma}{m\_subst\_lemma}{\coqdoclemma{m\_subst\_lemma}}: \coqdockw{\ensuremath{\forall}} \coqdef{lambda es.e1:399}{e1}{\coqdocbinder{e1}} \coqdef{lambda es.e2:400}{e2}{\coqdocbinder{e2}} \coqdef{lambda es.x:401}{x}{\coqdocbinder{x}} \coqdef{lambda es.e3:402}{e3}{\coqdocbinder{e3}} \coqdef{lambda es.y:403}{y}{\coqdocbinder{y}}, \coqref{lambda es.x:401}{\coqdocvariable{x}} \coqexternalref{::type scope:x '<>' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\not=}}} \coqref{lambda es.y:403}{\coqdocvariable{y}} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.x:401}{\coqdocvariable{x}} \coqdocnotation{`}\coqdocnotation{notin}\coqdocnotation{`} \coqdocnotation{(}\coqref{lambda es.fv nom}{\coqdocdefinition{fv\_nom}} \coqref{lambda es.e3:402}{\coqdocvariable{e3}}\coqdocnotation{)} \coqexternalref{::type scope:x '->' x}{http://coq.inria.fr/distrib/V8.16.1/stdlib//Coq.Init.Logic}{\coqdocnotation{\ensuremath{\rightarrow}}} \coqref{lambda es.:::x '=a' x}{\coqdocnotation{(}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{[}}\coqref{lambda es.y:403}{\coqdocvariable{y}} \coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{:=}} \coqref{lambda es.e3:402}{\coqdocvariable{e3}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{]([}}\coqref{lambda es.x:401}{\coqdocvariable{x}} \coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{:=}} \coqref{lambda es.e2:400}{\coqdocvariable{e2}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{]}}\coqref{lambda es.e1:399}{\coqdocvariable{e1}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{)}}\coqref{lambda es.:::x '=a' x}{\coqdocnotation{)}} \coqref{lambda es.:::x '=a' x}{\coqdocnotation{=}}\coqref{lambda es.:::x '=a' x}{\coqdocnotation{a}} \coqref{lambda es.:::x '=a' x}{\coqdocnotation{(}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{[}}\coqref{lambda es.x:401}{\coqdocvariable{x}} \coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{:=}} \coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{([}}\coqref{lambda es.y:403}{\coqdocvariable{y}} \coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{:=}} \coqref{lambda es.e3:402}{\coqdocvariable{e3}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{]}}\coqref{lambda es.e2:400}{\coqdocvariable{e2}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{)]([}}\coqref{lambda es.y:403}{\coqdocvariable{y}} \coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{:=}} \coqref{lambda es.e3:402}{\coqdocvariable{e3}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{]}}\coqref{lambda es.e1:399}{\coqdocvariable{e1}}\coqref{lambda es.:::'[' x ':=' x ']' x}{\coqdocnotation{)}}\coqref{lambda es.:::x '=a' x}{\coqdocnotation{)}}.\coqdoceol
\end{coqdoccode}
\noindent{\bf Proof.} The proof is by induction on the size of the term \coqdocvar{e1}. The interesting cases are the abstraction and the explicit substitution.
\begin{coqdoccode}
\end{coqdoccode}
In the abstraction case, the initial goal is ([\coqdocvar{y} := \coqdocvar{e3}] ([\coqdocvar{x} := \coqdocvar{e2}] \coqdocvar{n\_abs} \coqdocvar{z} \coqdocvar{e1})) =\coqdocvar{a} ([\coqdocvar{x} := [\coqdocvar{y} := \coqdocvar{e3}] \coqdocvar{e2}] ([\coqdocvar{y} := \coqdocvar{e3}] \coqdocvar{n\_abs} \coqdocvar{z} \coqdocvar{e1})), assuming that \coqdocvar{x} \ensuremath{\not=} \coqdocvar{y} and \coqdocvar{x} `\coqdocvar{notin}` \coqdocvar{fv\_nom} \coqdocvar{e3}. The induction hypothesis generated by this case states that the lemma can be propagated to a swap inside a metasubstitution that is applied to a term thath has the same size as \coqdocvar{e1} and the same hypothesis for the main lemma also apply to this case. We start comparing \coqdocvar{z} with \coqdocvar{x} aiming to apply the definition of the metasubstitution on the LHS of the goal.
\begin{coqdoccode}
\end{coqdoccode}
When \coqdocvar{z} = \coqdocvar{x}, the subterm [\coqdocvar{x} := \coqdocvar{e2}](\coqdocvar{n\_abs} \coqdocvar{x} \coqdocvar{e1}) is reduced to (\coqdocvar{n\_abs} \coqdocvar{x} \coqdocvar{e1}) by applying the lemma in m\_subst\_abs\_eq and then the LHS reduces to ([\coqdocvar{y} := \coqdocvar{e3}] \coqdocvar{n\_abs} \coqdocvar{x} \coqdocvar{e1}). The RHS reduces to ([\coqdocvar{y} := \coqdocvar{e3}] \coqdocvar{n\_abs} \coqdocvar{x} \coqdocvar{e1}) because \coqdocvar{x} does not occur free neither in (\coqdocvar{n\_abs} \coqdocvar{x} \coqdocvar{e1}) nor in \coqdocvar{e3}, which has also been proved.
\begin{coqdoccode}
\end{coqdoccode}
When \coqdocvar{y} = \coqdocvar{z} then the subterm ([\coqdocvar{y} := \coqdocvar{e3}] \coqdocvar{n\_abs} \coqdocvar{z} \coqdocvar{e1}) reduces to (\coqdocvar{n\_abs} \coqdocvar{z} \coqdocvar{e1}), by applying the lemma m\_subst\_abs\_neq which also generates certain hypothesis that help prove this fact. On the LHS, we propagate the internal metasubstitution over the abstraction taking a fresh name for the binder that is necessary because of the hypothesys generated using the lemma m\_subst\_abs\_neq as explained previously. Let \coqdocvar{w} be a new name that is not in the set $fv(\lambda_z'.e_1) \cup fv(e3) \cup fv(e2) \cup \{x\}$. The resulting terms are $\alpha$-equivalent, and although the strategy is similar to the one used in the lemmas \coqdocvar{aeq\_m\_subst\_in}, \coqdocvar{aeq\_m\_subst\_out} and \coqdocvar{swap\_subst\_rec\_fun} the proof requires much more steps. First, we apply the transitivity of the $\alpha$-equivalency using (\coqdocvar{z} := \coqdocvar{e3} n\_abs w (\coqdocvar{x} := \coqdocvar{e2} swap z w e1)) as intermediate term. The first case is the $\alpha$-equivalency of LHS with this new term, wich is solved by applying aeq\_m\_subst\_out trivially. 
\begin{coqdoccode}
\end{coqdoccode}
The other case is the $\alpha$-equivalency of RHS with this new term. In this case it was necessary to compare other two pairs of variables. Initially, we compared \coqdocvar{z} and \coqdocvar{w}.
\begin{coqdoccode}
\end{coqdoccode}
When \coqdocvar{z} = \coqdocvar{w} then in the LHS the metasubstitution is removed using the lemma \coqdocvar{m\_subst\_abs\_eq} and the subterm ([\coqdocvar{w} := \coqdocvar{e2}] \coqdocvar{swap} \coqdocvar{w} \coqdocvar{w} \coqdocvar{e1}) is reduced to ([\coqdocvar{w} := \coqdocvar{e2}]) \coqdocvar{e1}, remaining only \coqdocvar{n\_abs} \coqdocvar{w} ([\coqdocvar{x} := \coqdocvar{e2}] \coqdocvar{e1}). On the RHS, we propagate the internal metasubstitution over the abstraction taking the \coqdocvar{w} as the new variable for this substitution. Then, the lemma \coqdocvar{aeq\_abs\_same} is used to remove the abstractions on both sides of the $\alpha$-equivalency and because they have the same variable, all we have to do is assure that the expressions are $\alpha$-equivalent. By applying the lemma \coqdocvar{aeq\_m\_subst\_in}, we can see that they are. 
\begin{coqdoccode}
\end{coqdoccode}
In the last part of this case, we propagate the internal metasubstitution over the abstraction taking a fresh name for the binder that is necessary because of the hypothesys generated using the lemma m\_subst\_abs\_neq as explained previously. Let \coqdocvar{w'} be a new name that is not in the set $fv(\lambda_z'.e_1) \cup fv(e3) \cup fv(e2) \cup \{x\}$. We then proceed by comparing \coqdocvar{w} and \coqdocvar{w'}.
\begin{coqdoccode}
\end{coqdoccode}
When \coqdocvar{w} == \coqdocvar{w'}, the proof if given by removing the abstractions from inside the metasubstitutions using the lemma \coqdocvar{m\_subst\_abs\_neq} and the new variable \coqdocvar{w'}. Then we remove them altogether using the lemma \coqdocvar{aeq\_abs\_same}, given that the variables in the abstractions are the same. The subterm \coqdocvar{swap} \coqdocvar{w'} \coqdocvar{w'} ([\coqdocvar{x} := \coqdocvar{e2}] \coqdocvar{swap} \coqdocvar{z} \coqdocvar{w'} \coqdocvar{e1}) gets simplified to ([\coqdocvar{x} := \coqdocvar{e2}] \coqdocvar{swap} \coqdocvar{z} \coqdocvar{w'} \coqdocvar{e1}), in the LHS. What remain is simmilar to what we have in our induction hypothesys, which is applied to our conclusion and the rest of the proof is solved trivially. The case in which \coqdocvar{w} \ensuremath{\not=} \coqdocvar{w'} is solved similarly.
\begin{coqdoccode}
\end{coqdoccode}
In the explicit substitution case, we used the same approach used in the abstraction for the left side and the same as the application for the right side of the substitution. It consisted of comparing the variable in the meta substitution and the one in the substitution. We used the auxiliary lemmas on the equality and inequality of the meta-substitution applied to explicit substitutions and it was necessary to create new variables in each use of the inequality. This is due to the atempt of removing the explicit substitution from inside the meta-substitution. When tis removal was made, the proof consisted in proving a similar case for the abstraction in the left side of the explicit substitution and the one similar to the application was used for the right part of it.$\hfill\Box$
\begin{coqdoccode}
\coqdocemptyline
\end{coqdoccode}
\section{Conclusion and Future work}



 In this work, we presented a formalization of the substitution lemma in a framework that extends the $\lambda$-calculus with an explicit substitution operator. Calculi with explicit substitutions are important frameworks to study properties of the $\lambda$-calculus and have been extensively studied in the last decades\cite{abadiExplicitSubstitutions1991,accattoliAbstractFactorizationTheorem2012,ayala-rinconComparingCalculiExplicit2002,ayala-rinconComparingImplementingCalculi2005,bonelliPerpetualityNamedLambda2001,fujitaChurchRosserTheoremCompositional2016}. 


The formalization is modular in the sense that the explicit substitution operator is generic and could be instantiated with any calculi with  explicit substitutions in a nominal setting. The main contribution of this work, besides the formalization itself, is the solution to a circular proof problem. Several auxiliary (minor) results were not included in this document, but they are numerous and can be found in the source file of the formalization that is available in a GitHub repository from the following url \url{https://github.com/flaviodemoura/lx_confl/tree/m_subst_lemma}.


As future work, we plan to integrate this formalization with another one related to the Z property \cite{fmm2021} to prove properties of calculi with explicit substitutions such as confluence\cite{nakazawaCompositionalConfluenceProofs2016,nakazawaCallbyvalue2017,kesnerPerpetualityFullSafe2008}. 
\begin{coqdoccode}
\end{coqdoccode}
